<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UE5 STE Question Generator (Real-Time Cloud)</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Lucide Icons (Global) -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Firebase SDK (Firestore and Auth) - v11.6.1 -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, query, where, getDocs, addDoc, setDoc, doc, deleteDoc, writeBatch, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Expose Firebase modules globally for use in the Babel script block
        window.Firebase = {
            initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, signOut,
            getFirestore, collection, query, where, getDocs, addDoc, setDoc, doc, deleteDoc, writeBatch, onSnapshot
        };
        window.isFirebaseLoaded = true;
    </script>


    <style>
        /* Custom Scrollbar for dark theme */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0f172a;
        }

        ::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #475569;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .animate-in {
            animation: fadeIn 0.3s ease-out forwards;
        }

        /* Custom styling for the Export Options dropdown */
        .export-options-menu {
            z-index: 50;
            width: 320px;
            padding: 12px;
            background-color: #0f172a;
            /* slate-950 */
            border: 1px solid #334155;
            /* slate-700 */
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>

<body class="bg-slate-950 text-slate-200 h-screen overflow-hidden">
    <div id="root" class="h-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // --- APPLICATION VERSION ---
        const APP_VERSION = "v1.3"; // Updated version

        // --- Configuration & Constants ---
        const LANGUAGE_FLAGS = {
            'English': 'ðŸ‡ºðŸ‡¸',
            'Chinese (Simplified)': 'ðŸ‡¨ðŸ‡³',
            'Japanese': 'ðŸ‡¯ðŸ‡µ',
            'Korean': 'ðŸ‡°ðŸ‡·',
            'Spanish': 'ðŸ‡ªðŸ‡¸',
            'French': 'ðŸ‡«ðŸ‡·',
            'German': 'ðŸ‡©ðŸ‡ª',
            'Italian': 'ðŸ‡®ðŸ‡¹',
            'Portuguese': 'ðŸ‡µðŸ‡¹',
            'Russian': 'ðŸ‡·ðŸ‡º'
        };

        // Short codes for the "missing translation" state
        const LANGUAGE_CODES = {
            'English': 'US',
            'Chinese (Simplified)': 'CN',
            'Japanese': 'JP',
            'Korean': 'KR',
            'Spanish': 'ES',
            'French': 'FR',
            'German': 'DE',
            'Italian': 'IT',
            'Portuguese': 'PT',
            'Russian': 'RU'
        };

        const CATEGORY_KEYS = ['Easy MC', 'Easy T/F', 'Medium MC', 'Medium T/F', 'Hard MC', 'Hard T/F'];
        const TARGET_PER_CATEGORY = 33;
        const TARGET_TOTAL = 200;
        const FIELD_DELIMITER = ','; // CSV Standard

        // --- Icon Component for Browser CDN (Lucide) ---
        const Icon = ({ name, size = 16, className = "" }) => {
            const [svgHtml, setSvgHtml] = useState("");

            useEffect(() => {
                if (typeof lucide === 'undefined') return;

                const pascalName = name.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('');
                const iconDef = lucide.icons[pascalName];

                if (iconDef) {
                    const svgNode = lucide.createElement(iconDef);
                    svgNode.setAttribute('width', size);
                    svgNode.setAttribute('height', size);
                    if (className) svgNode.setAttribute('class', `lucide lucide-${name} ${className}`);
                    setSvgHtml(svgNode.outerHTML);
                }
            }, [name, size, className]);

            if (!svgHtml) return <span style={{ width: size, height: size, display: 'inline-block' }} />;
            return <span dangerouslySetInnerHTML={{ __html: svgHtml }} className="inline-flex items-center justify-center" />;
        };

        // --- API Configuration & Utilities (Ensured Global Scope) ---

        const chunkArray = (array, size) => {
            const result = [];
            for (let i = 0; i < array.length; i += size) {
                result.push(array.slice(i, i + size));
            }
            return result;
        };

        const formatUrl = (url) => {
            if (!url) return '';
            let cleanUrl = url.trim();
            if (!/^[a-zA-Z]+:\/\//.test(cleanUrl) && (cleanUrl.includes('.') && !cleanUrl.includes(' '))) {
                if (!cleanUrl.toLowerCase().endsWith('.csv') && !cleanUrl.toLowerCase().endsWith('.txt')) {
                    cleanUrl = 'https://' + cleanUrl;
                }
            }
            return cleanUrl;
        };

        const sanitizeText = (text) => {
            if (typeof text !== 'string') return String(text);
            let output = text.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>').replace(/\*\*/g, '');
            const temp = document.createElement('div');
            temp.innerHTML = output;
            return temp.innerHTML;
        };

        const stripHtmlTags = (text) => {
            if (typeof text !== 'string') return text;
            const tmp = document.createElement("DIV");
            tmp.innerHTML = text;
            return tmp.textContent || tmp.innerText || "";
        };

        const safe = (t) => {
            const str = String(t);
            let content = stripHtmlTags(str);
            content = (content || '').trim();
            content = content.replace(/[\u200B\uFEFF\u00A0]/g, ' ').replace(/\s\s+/g, ' ').trim();
            content = content.replace(/(\r\n|\n|\r|\t)/gm, ' ');
            content = content.replace(/['"]/g, '');
            const escaped = content.replace(/"/g, '""');
            return `"${escaped}"`;
        };

        const formatDate = (date = new Date()) => {
            const mm = (date.getMonth() + 1).toString().padStart(2, '0');
            const dd = date.getDate().toString().padStart(2, '0');
            const yyyy = date.getFullYear();
            return `${yyyy}-${mm}-${dd}`;
        };

        const parseCSVLine = (text) => {
            const result = [];
            let cell = '';
            let insideQuote = false;
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                if (char === '"') {
                    if (insideQuote && text[i + 1] === '"') {
                        cell += '"';
                        i++;
                    } else {
                        insideQuote = !insideQuote;
                    }
                } else if (char === ',' && !insideQuote) {
                    result.push(cell);
                    cell = '';
                } else {
                    cell += char;
                }
            }
            result.push(cell);
            return result;
        };

        const generateContent = async (effectiveKey, systemPrompt, userPrompt, setStatus) => {
            // Note: If effectiveKey is "", the platform runtime will inject the correct key.
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${effectiveKey}`;

            const payload = {
                contents: [{ parts: [{ text: userPrompt }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                tools: [{ google_search: {} }],
                generationConfig: {
                    temperature: 0.2,
                    maxOutputTokens: 8192
                }
            };

            let retries = 0;
            const maxRetries = 2;
            const backoffDelays = [2000, 5000];

            while (retries <= maxRetries) {
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error?.message || `API Error: ${response.status}`);
                    }

                    const data = await response.json();
                    const candidate = data.candidates?.[0];
                    const textResponse = candidate?.content?.parts?.[0]?.text;
                    const finishReason = candidate?.finishReason;

                    if (!textResponse && finishReason !== 'STOP') {
                        throw new Error(finishReason || 'No content generated');
                    }

                    return textResponse || "";

                } catch (error) {
                    console.error(`Attempt ${retries + 1} failed:`, error);
                    if (retries === maxRetries) throw error;
                    setStatus(`Retrying... (${retries + 1}/${maxRetries})`);
                    await new Promise(resolve => setTimeout(resolve, backoffDelays[retries]));
                    retries++;
                }
            }
        };

        const parseQuestions = (text) => {
            const parsed = [];
            const lines = text.split('\n');

            const dataLines = lines.filter(line => {
                const trimmed = line.trim();
                return (trimmed.startsWith('|') || trimmed.startsWith('ï½œ')) &&
                    !trimmed.includes('| ID |') &&
                    !trimmed.includes('ï½œ ID ï½œ') &&
                    !trimmed.includes('|---');
            });

            dataLines.forEach((line, index) => {
                const normalizedLine = line.replace(/ï½œ/g, '|');
                let cols = normalizedLine.split('|').map(c => c.trim());

                if (cols[0] === '') cols.shift();
                if (cols[cols.length - 1] === '') cols.pop();

                if (cols.length >= 10) {
                    const looksLikeAnswer = (val) => /^[A-D]$/.test(val);
                    const looksLikeUrl = (val) => val && val.startsWith('http');
                    if (cols[9] && looksLikeAnswer(cols[9]) && cols[10] && looksLikeUrl(cols[10])) {
                        cols.splice(5, 0, "");
                    }
                }

                const discipline = cols[1];
                const typeRaw = cols[2];
                const difficulty = cols[3];
                const question = cols[4];
                const optA = cols[6];
                const optB = cols[7];
                const optC = cols[8];
                const optD = cols[9];
                const correctLetter = cols[10];
                const sourceUrl = cols[11];
                const sourceExcerpt = cols[12];

                if (!question || !correctLetter || question.includes('---')) return;

                const type = typeRaw && typeRaw.toLowerCase().includes('true') ? 'True/False' : 'Multiple Choice';

                let options = {};
                if (type === 'True/False') {
                    options = { A: 'TRUE', B: 'FALSE' };
                } else {
                    options = { A: optA || '', B: optB || '', C: optC || '', D: optD || '' };
                }

                const uniqueId = crypto.randomUUID();

                parsed.push({
                    id: Date.now() + index + Math.random(),
                    uniqueId: uniqueId,
                    discipline: discipline || "General",
                    type: type || "Multiple Choice",
                    difficulty: difficulty || "Easy",
                    question: question || "",
                    options,
                    correct: correctLetter || "",
                    sourceUrl: sourceUrl || "",
                    sourceExcerpt: sourceExcerpt || "",
                    status: 'pending',
                    critique: null
                });
            });

            return parsed;
        };
        // --- End of Utilities ---

        // --- Shared Components (Defined early for scope safety) ---

        const InfoTooltip = ({ text, direction = "up" }) => (
            <div className="group relative inline-flex items-center ml-1.5 align-middle">
                <Icon name="info" size={12} className="text-slate-600 hover:text-orange-500 cursor-help transition-colors" />
                <div className={`invisible group-hover:visible opacity-0 group-hover:opacity-100 transition-all duration-200 absolute left-1/2 -translate-x-1/2 w-48 p-2.5 bg-slate-800 border border-slate-700 text-slate-200 text-[10px] leading-relaxed rounded-md shadow-xl z-50 pointer-events-none text-center ${direction === 'down' ? 'top-full mt-2' : 'bottom-full mb-2'}`}>
                    {text}
                    <div className={`absolute left-1/2 -translate-x-1/2 border-4 border-transparent ${direction === 'down' ? 'bottom-full border-b-slate-800' : 'top-full border-t-slate-800'}`}></div>
                </div>
            </div>
        );

        const NameEntryModal = ({ onSave }) => {
            const [name, setName] = useState('');
            const [sillyPlaceholder, setSillyPlaceholder] = useState('');

            useEffect(() => {
                const sillyNames = ["Captain Blueprint", "Sir Render-Lot", "Polygon Prince", "Texture Titan"];
                setSillyPlaceholder(`e.g. ${sillyNames[Math.floor(Math.random() * sillyNames.length)]}`);
            }, []);

            const handleSubmit = (e) => {
                e.preventDefault();
                if (name.trim()) onSave(name);
            };

            return (
                <div className="fixed inset-0 bg-black/90 z-[100] flex items-center justify-center backdrop-blur-sm p-4">
                    <div className="bg-slate-900 border border-slate-700 p-8 rounded-xl shadow-2xl max-w-md w-full animate-in zoom-in-95 duration-300">
                        <div className="flex flex-col items-center text-center mb-6">
                            <div className="bg-orange-600 p-3 rounded-full mb-4 shadow-lg shadow-orange-900/50">
                                <Icon name="user" size={32} className="text-white" />
                            </div>
                            <h2 className="text-2xl font-bold text-white mb-2">Welcome, Creator / Reviewer</h2>
                            <p className="text-slate-400 text-sm">Please enter your name to identify your contributions.</p>
                        </div>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div className="space-y-1 text-left">
                                <label className="text-xs font-bold uppercase text-slate-500 tracking-wider">Your Full Name (For Creating & Reviewing)</label>
                                <input type="text" name="creatorName" value={name} onChange={(e) => setName(e.target.value)} placeholder={sillyPlaceholder} className="w-full px-4 py-3 bg-slate-950 border border-slate-700 rounded-lg focus:ring-2 focus:ring-orange-500 outline-none text-white placeholder-slate-600 transition-all" autoFocus />
                            </div>
                            <button type="submit" disabled={!name.trim()} className="w-full py-3 px-4 bg-orange-600 hover:bg-orange-700 disabled:bg-slate-700 disabled:cursor-not-allowed text-white font-bold rounded-lg transition-all shadow-lg active:scale-[0.98]">
                                Set Identity & Start
                            </button>
                        </form>
                    </div>
                </div>
            );
        };

        // --- New Components (Defined Outside App) ---

        const LandingPage = ({ onSelectMode, apiKeyStatus, isCloudReady }) => (
            <div className="flex flex-col items-center justify-center min-h-screen bg-slate-950 text-white p-4 relative overflow-hidden">
                {/* Background Decoration */}
                <div className="absolute top-0 left-0 w-full h-full opacity-10 pointer-events-none">
                    <div className="absolute top-1/4 left-1/4 w-96 h-96 bg-orange-600 rounded-full blur-3xl"></div>
                    <div className="absolute bottom-1/4 right-1/4 w-96 h-96 bg-indigo-600 rounded-full blur-3xl"></div>
                </div>

                <div className="z-10 text-center space-y-8 max-w-2xl animate-in fade-in zoom-in-95 duration-500">
                    <div className="space-y-4">
                        <div className="inline-flex items-center justify-center p-4 bg-slate-900 rounded-2xl border border-slate-800 shadow-2xl mb-4">
                            <Icon name="terminal" size={48} className="text-orange-500" />
                        </div>
                        <h1 className="text-4xl md:text-5xl font-extrabold tracking-tight">
                            UE5 STE <span className="text-transparent bg-clip-text bg-gradient-to-r from-orange-400 to-orange-600">Question Generator</span>
                        </h1>
                        <p className="text-lg text-slate-400 max-w-lg mx-auto">
                            Create, review, and manage scenario-based technical questions for Unreal Engine 5 documentation.
                        </p>
                    </div>

                    <div className="flex flex-col sm:flex-row gap-4 justify-center w-full">
                        <button
                            onClick={() => onSelectMode('create')}
                            className="group relative flex flex-col items-center p-6 bg-slate-900 border border-slate-800 hover:border-orange-500/50 rounded-xl hover:bg-slate-800/80 transition-all duration-300 w-full sm:w-64 shadow-lg hover:shadow-orange-900/20"
                        >
                            <div className="p-3 bg-orange-900/20 rounded-full mb-4 group-hover:scale-110 transition-transform">
                                <Icon name="plus-circle" size={32} className="text-orange-500" />
                            </div>
                            <h3 className="text-xl font-bold mb-2">Creation Mode</h3>
                            <p className="text-xs text-slate-400 text-center">Generate new questions, upload CSVs, and translate content.</p>
                        </button>

                        <button
                            onClick={() => onSelectMode('review')}
                            className="group relative flex flex-col items-center p-6 bg-slate-900 border border-slate-800 hover:border-indigo-500/50 rounded-xl hover:bg-slate-800/80 transition-all duration-300 w-full sm:w-64 shadow-lg hover:shadow-indigo-900/20"
                        >
                            <div className="p-3 bg-indigo-900/20 rounded-full mb-4 group-hover:scale-110 transition-transform">
                                <Icon name="list-checks" size={32} className="text-indigo-500" />
                            </div>
                            <h3 className="text-xl font-bold mb-2">Review Mode</h3>
                            <p className="text-xs text-slate-400 text-center">Manage existing database, approve/reject questions, and bulk export.</p>
                        </button>
                    </div>

                    <div className="flex items-center justify-center gap-6 text-xs text-slate-500 font-mono pt-8">
                        <div className="flex items-center gap-2">
                            <div className={`w-2 h-2 rounded-full ${apiKeyStatus.includes('Loaded') || apiKeyStatus.includes('Auto') ? 'bg-green-500' : 'bg-red-500'}`}></div>
                            API Key: {apiKeyStatus}
                        </div>
                        <div className="flex items-center gap-2">
                            <div className={`w-2 h-2 rounded-full ${isCloudReady ? 'bg-blue-500' : 'bg-orange-500'}`}></div>
                            {isCloudReady ? 'Cloud Connected' : 'Local Mode'}
                        </div>
                    </div>
                </div>
            </div>
        );

        const Header = ({ apiKeyStatus, isCloudReady, onHome, creatorName }) => (
            <header className="bg-slate-950 text-white p-6 shadow-xl border-b border-orange-600 relative z-20">
                <div className="max-w-7xl mx-auto flex items-center justify-between">
                    <div className="flex items-center gap-3 cursor-pointer" onClick={onHome} title="Back to Home">
                        <div className="bg-orange-600 p-2 rounded-lg shadow-lg shadow-orange-900/50">
                            <Icon name="terminal" size={24} className="text-white" />
                        </div>
                        <div>
                            <h1 className="text-xl font-bold tracking-tight uppercase text-orange-50">
                                UE5 STE Question Generator
                                <span className="text-xs text-slate-400 font-normal ml-3 border border-slate-700 rounded-full px-2 py-0.5 align-top inline-block">{APP_VERSION}</span>
                            </h1>
                            <p className="text-slate-400 text-xs">Universal Scenario-Based Generator â€¢ Official Docs Only</p>
                        </div>
                    </div>
                    <div className="hidden md:flex items-center gap-4 text-xs font-mono">
                        {creatorName && (
                            <div className="flex items-center gap-1.5 font-bold text-slate-300 px-3 py-1 bg-slate-800/50 rounded-lg">
                                <Icon name="user-check" size={14} className="text-green-500" />
                                <span>{creatorName}</span>
                            </div>
                        )}
                        <div className="flex items-center gap-2 px-3 py-1 rounded border border-slate-700">
                            <span className={`font-bold ${apiKeyStatus.includes('Loaded') || apiKeyStatus.includes('Auto') ? 'text-green-400' : 'text-red-400'}`}>API Key: {apiKeyStatus}</span>
                            {isCloudReady ? (
                                <div className="flex items-center gap-1.5 text-blue-400 font-bold border-l border-slate-700 pl-2 ml-2">
                                    <div className="w-2 h-2 bg-blue-500 rounded-full animate-pulse"></div>
                                    <span>CLOUD LIVE</span>
                                </div>
                            ) : (
                                <span className="text-orange-400 font-bold border-l border-slate-700 pl-2 ml-2">LOCAL MODE</span>
                            )}
                        </div>
                    </div>
                </div>
            </header>
        );

        const CritiqueDisplay = ({ critique }) => (
            <div className="mb-3 p-3 bg-red-950/30 border border-red-500/30 rounded-lg animate-in fade-in slide-in-from-top-2">
                <div className="flex items-center gap-2 mb-2 text-red-300 text-xs font-bold uppercase">
                    <Icon name="zap" size={12} /> AI Critique
                </div>
                <div className="text-xs text-slate-300 leading-relaxed space-y-1.5">
                    {critique.split('\n').map((line, index) => {
                        if (line.match(/^(\*|-|\d+\.)\s/)) {
                            return <p key={index} className="pl-3 text-red-100/80 indent-[-12px]">{line.trim()}</p>;
                        }
                        return <p key={index}>{line.trim()}</p>;
                    })}
                </div>
            </div>
        );

        // Blocking Modal Component 
        const BlockingProcessModal = ({ isProcessing, status, translationProgress }) => {
            if (!isProcessing) return null;

            return (
                <div className="fixed inset-0 bg-black/70 z-[100] flex items-center justify-center p-4 backdrop-blur-sm">
                    <div className="bg-slate-900 border border-orange-600 p-8 rounded-xl shadow-2xl max-w-sm w-full animate-in zoom-in-95 duration-300 space-y-4 text-center">
                        <Icon name="loader" size={32} className="text-orange-500 mx-auto animate-spin mb-4" />
                        <h3 className="text-xl font-bold text-white">Working on Data...</h3>
                        <p className="text-sm text-slate-300">{status}</p>
                        {translationProgress > 0 && translationProgress < 100 && (
                            <div className="relative h-2 w-full bg-indigo-900 rounded-lg overflow-hidden mt-4">
                                <div className="h-full bg-indigo-500 transition-all duration-300" style={{ width: `${translationProgress}%` }}></div>
                            </div>
                        )}
                        {translationProgress > 0 && <span className="text-xs text-indigo-400 font-bold">{translationProgress}% Complete</span>}
                    </div>
                <div className="fixed inset-0 bg-black/70 z-[100] flex items-center justify-center p-4 backdrop-blur-sm" onClick={onClose}>
                    {children}
                </div>
            );
        };

        const QuestionItem = ({ q, onUpdateStatus, onExplain, onVariate, onCritique, onTranslateSingle, onSwitchLanguage, availableLanguages, isProcessing }) => {
            const [menuOpen, setMenuOpen] = useState(false);
            const menuRef = useRef(null);

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (menuRef.current && !menuRef.current.contains(event.target)) {
                        setMenuOpen(false);
                    }
                };
                document.addEventListener("mousedown", handleClickOutside);
                return () => document.removeEventListener("mousedown", handleClickOutside);
            }, []);

            const getStatusStyle = (status) => {
                switch (status) {
                    case 'accepted': return 'ring-1 ring-green-500/50';
                    case 'rejected': return 'border-red-900/50 bg-slate-950/80 opacity-50 grayscale';
                    default: return '';
                }
            };

            const getGradient = (d) => {
                switch (d?.toLowerCase()) {
                    case 'easy': return 'bg-gradient-to-br from-slate-900/50 to-green-950 border-green-700 shadow-[0_0_15px_-5px_rgba(34,197,94,0.3)]';
                    case 'medium': return 'bg-gradient-to-br from-slate-900/50 to-yellow-950 border-yellow-700 shadow-[0_0_15px_-5px_rgba(234,179,8,0.3)]';
                    case 'hard': return 'bg-gradient-to-br from-slate-900/50 to-red-950 border-red-700 shadow-[0_0_15px_-5px_rgba(239,68,68,0.3)]';
                    default: return 'bg-slate-900 border-slate-800';
                }
            };

            const getDiffBadgeColor = (d) => {
                switch (d?.toLowerCase()) {
                    case 'easy': return 'bg-green-950 text-green-400 border-green-900';
                    case 'medium': return 'bg-yellow-950 text-yellow-400 border-yellow-900';
                    case 'hard': return 'bg-red-950 text-red-400 border-red-900';
                    default: return 'bg-slate-800 text-slate-400 border-slate-700';
                }
            };

            const isRejected = q.status === 'rejected';

            // Track loading state per specific language flag
            const [loadingLang, setLoadingLang] = useState(null);

            const handleFlagClick = async (e, lang) => {
                e.stopPropagation();

                // Check if the translation ALREADY exists
                if (availableLanguages && availableLanguages.has(lang)) {
                    // It exists -> SWITCH VIEW
                    onSwitchLanguage(lang);
                } else {
                    // It doesn't exist -> GENERATE
                    setLoadingLang(lang);
                    await onTranslateSingle(q, lang);
                    setLoadingLang(null);
                }
            };

            const renderLanguageFlags = () => {
                // Get all available language names, excluding the current language of the displayed card.
                const allLanguageNames = Object.keys(LANGUAGE_FLAGS).filter(lang => (q.language || 'English').trim() !== lang);

                return allLanguageNames.map(lang => {
                    const hasLang = availableLanguages && availableLanguages.has(lang);
                    const langCode = LANGUAGE_CODES[lang] || lang.substring(0, 2).toUpperCase();
                    const flag = LANGUAGE_FLAGS[lang];
                    const isLoading = loadingLang === lang;

                    // If Translation Exists -> Show FLAG (Switch button)
                    if (hasLang) {
                        return (
                            <button
                                key={lang}
                                onClick={(e) => handleFlagClick(e, lang)}
                                className="text-sm px-1 inline-flex items-center justify-center opacity-100 hover:scale-125 transition-transform cursor-pointer"
                                title={`Switch to ${lang} translation`}
                            >
                                {flag}
                            </button>
                        );
                    }

                    // If Missing -> Show 2-Letter Code (Generate button)
                    return (
                        <button
                            key={lang}
                            onClick={(e) => handleFlagClick(e, lang)}
                            disabled={isProcessing}
                            className={`text-[10px] font-bold px-1 py-0.5 text-slate-600 hover:text-slate-300 transition-colors ${isLoading ? 'animate-pulse text-orange-500' : ''}`}
                            title={`Generate ${lang} translation`}
                        >
                            {isLoading ? <Icon name="loader" size={10} className="animate-spin" /> : langCode}
                        </button>
                    );
                });
            };

            return (
                <div className={`group rounded-lg border shadow-sm transition-all p-4 relative ${getGradient(q.difficulty)} ${getStatusStyle(q.status)}`}>
                    <div className="flex flex-col gap-2 mb-3">
                        {/* Top Row: Badges */}
                        <div className="flex justify-between items-start">
                            <div className="flex flex-col gap-1">
                                <div className="flex gap-2 items-center">
                                    <span className={`px-2 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider border ${getDiffBadgeColor(q.difficulty)}`}>{q.difficulty}</span>
                                    <span className="px-2 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider border bg-blue-950 text-blue-400 border-blue-900">{q.type === 'True/False' ? 'T/F' : 'MC'}</span>
                                    <span className="px-2 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider border bg-slate-700 text-slate-300 border-slate-600 flex items-center gap-1">
                                        {LANGUAGE_CODES[q.language || 'English']} {(q.language || 'English').toUpperCase()}
                                    </span>
                                </div>
                            </div>

                            <div className="flex items-center gap-2">
                                {/* More Menu */}
                                <div className="relative" ref={menuRef}>
                                    <button onClick={(e) => { e.stopPropagation(); setMenuOpen(!menuOpen); }} className="p-2 hover:bg-slate-800 rounded-full text-slate-400 hover:text-white transition-colors">
                                        <Icon name="more-vertical" size={16} />
                                    </button>

                                    {/* Dropdown */}
                                    {menuOpen && (
                                        <div className="absolute right-0 top-full mt-1 w-48 bg-slate-800 border border-slate-700 rounded-lg shadow-xl z-50 overflow-hidden animate-in fade-in zoom-in-95 duration-200">
                                            <div className="py-1">
                                                {isRejected && (
                                                    <button onClick={(e) => { e.stopPropagation(); onCritique(q); setMenuOpen(false); }} className="w-full text-left px-4 py-2 text-xs text-red-400 hover:bg-slate-700 flex items-center gap-2">
                                                        <Icon name="zap" size={14} /> AI Critique
                                                    </button>
                                                )}
                                                <button onClick={(e) => { e.stopPropagation(); onExplain(q); setMenuOpen(false); }} className="w-full text-left px-4 py-2 text-xs text-indigo-300 hover:bg-slate-700 flex items-center gap-2">
                                                    <Icon name="lightbulb" size={14} /> Explain Answer
                                                </button>
                                                <button onClick={(e) => { e.stopPropagation(); onVariate(q); setMenuOpen(false); }} className="w-full text-left px-4 py-2 text-xs text-purple-300 hover:bg-slate-700 flex items-center gap-2">
                                                    <Icon name="copy" size={14} /> Create Variations
                                                </button>
                                                <button onClick={(e) => {
                                                    e.stopPropagation();
                                                    const textArea = document.createElement("textarea");
                                                    // FIX: Use stripHtmlTags for clean copy
                                                    textArea.value = stripHtmlTags(q.question);
                                                    document.body.appendChild(textArea);
                                                    textArea.select();
                                                    try {
                                                        document.execCommand('copy');
                                                    } catch (err) {
                                                        console.error('Fallback: Oops, unable to copy', err);
                                                    }
                                                    document.body.removeChild(textArea);
                                                    setMenuOpen(false);
                                                }} className="w-full text-left px-4 py-2 text-xs text-slate-300 hover:bg-slate-700 flex items-center gap-2">
                                                    <Icon name="clipboard" size={14} /> Copy Question
                                                </button>
                                            </div>
                                        </div>
                                    )}
                                </div>

                                {/* Action Buttons (Large) */}
                                <div className="flex items-center gap-2">
                                    <button onClick={() => onUpdateStatus(q.id, 'accepted')} className={`p-2 rounded-lg transition-all ${q.status === 'accepted' ? 'bg-green-600 text-white shadow-lg shadow-green-900/50' : 'bg-slate-800 text-slate-500 hover:bg-green-900/20 hover:text-green-500'}`} title="Accept">
                                        <Icon name="check" size={18} />
                                    </button>
                                    <button onClick={() => onUpdateStatus(q.id, 'rejected')} className={`p-2 rounded-lg transition-all ${q.status === 'rejected' ? 'bg-red-600 text-white shadow-lg shadow-red-900/50' : 'bg-slate-800 text-slate-500 hover:bg-red-900/20 hover:text-red-500'}`} title="Reject">
                                        <Icon name="x" size={18} />
                                    </button>
                                </div>
                            </div>
                        </div>

                        {/* Second Row: Language Indicators (Flags or Codes) */}
                        <div className="flex flex-wrap gap-1.5 items-center pt-1">
                            {renderLanguageFlags()}
                        </div>
                    </div>

                    <div className="mb-4">
                        <h3 className={`text-sm font-medium leading-relaxed ${q.status === 'rejected' ? 'text-slate-600 line-through decoration-slate-700' : 'text-slate-200'}`} dangerouslySetInnerHTML={{ __html: sanitizeText(q.question) }} />
                        <div className="flex items-center gap-3 mt-2">
                            {q.sourceUrl && (
                                <div className="flex items-center gap-1.5 text-[10px] text-blue-500 truncate max-w-[70%]">
                                    <Icon name="external-link" size={12} className="flex-shrink-0" />
                                    <a href={formatUrl(q.sourceUrl)} target="_blank" rel="noreferrer" className="hover:underline truncate text-blue-500 hover:text-blue-400">{q.sourceUrl}</a>
                                </div>
                            )}
                            {/* DEBUG ID: Helps verify linking */}
                            <div className="text-[9px] text-slate-700 font-mono cursor-help" title={`Unique ID: ${q.uniqueId} (Use this to link translations)`}>
                                #{q.uniqueId.substring(0, 8)}
                            </div>
                        </div>
                    </div>

                    {q.type === 'Multiple Choice' && (
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-2 mb-4">
                            {Object.entries(q.options || {}).map(([key, val]) => {
                                const isCorrect = q.correct === key;
                                // SAFEGUARD: If option text is missing/empty, show placeholder to maintain layout
                                const optionText = val && val.trim() ? val : "(Empty)";
                                return (
                                    <div key={key} className={`text-xs p-2 rounded border transition-all ${isCorrect ? 'bg-green-700/50 border-green-400 text-white shadow-[0_0_10px_-3px_rgba(34,197,94,0.5)]' : 'bg-slate-950 border-slate-800 text-slate-400'}`}>
                                        <span className={`font-bold mr-2 ${isCorrect ? 'text-white' : 'text-slate-600'}`}>{key})</span>
                                        <span dangerouslySetInnerHTML={{ __html: sanitizeText(optionText) }} />
                                    </div>
                                );
                            })}
                        </div>
                    )}

                    {q.type === 'True/False' && (
                        <div className="flex gap-4 mb-4">
                            <div className={`px-3 py-1 rounded text-xs border transition-all ${q.correct === 'A' ? 'bg-green-700/50 border-green-400 text-white shadow-[0_0_10px_-3px_rgba(34,197,94,0.5)]' : 'bg-slate-950 border-slate-800 text-slate-500'}`}>TRUE</div>
                            <div className={`px-3 py-1 rounded text-xs border transition-all ${q.correct === 'B' ? 'bg-red-700/50 border-red-400 text-white shadow-[0_0_10px_-3px_rgba(239,68,68,0.5)]' : 'bg-slate-950 border-slate-800 text-slate-500'}`}>FALSE</div>
                        </div>
                    )}

                    {q.critique && <CritiqueDisplay critique={q.critique} />}

                    {q.explanation && (
                        <div className="mb-3 p-3 bg-indigo-950/30 border border-indigo-500/30 rounded-lg animate-in fade-in slide-in-from-top-2">
                            <div className="flex items-center gap-2 mb-1 text-indigo-300 text-xs font-bold uppercase"><Icon name="lightbulb" size={12} /> Explanation</div>
                            <p className="text-xs text-slate-300 leading-relaxed">{q.explanation}</p>
                        </div>
                    )}

                    {q.sourceExcerpt && (
                        <div className="pt-3 border-t border-slate-800 flex flex-col gap-1">
                            <div className="flex items-start gap-1.5 text-[10px] text-slate-500 italic bg-slate-950 p-2 rounded border border-slate-800">
                                <Icon name="message-square" size={12} className="mt-0.5 flex-shrink-0" />
                                "{q.sourceExcerpt}"
                            </div>
                        </div>
                    )}

                    {/* NEW: Creator/Reviewer Info */}
                    <div className="pt-3 mt-4 border-t border-slate-800 flex justify-between items-center text-xs text-slate-600">
                        <div className="flex items-center gap-1.5">
                            <Icon name="user" size={12} className="text-slate-700" />
                            <span className="font-medium">Created by: </span>
                            <span className="font-bold text-orange-400">{q.creatorName || 'N/A'}</span>
                        </div>
                        {q.reviewerName && q.reviewerName !== q.creatorName && (
                            <div className="flex items-center gap-1.5">
                                <Icon name="list-checks" size={12} className="text-slate-700" />
                                <span className="font-medium">Reviewed by: </span>
                                <span className="font-bold text-indigo-400">{q.reviewerName}</span>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const GranularProgress = ({ approvedCounts, target, isTargetMet, selectedDifficulty, handleSelectCategory }) => {
            const categories = ['Easy MC', 'Easy T/F', 'Medium MC', 'Medium T/F', 'Hard MC', 'Hard T/F'].map(key => {
                const current = approvedCounts[key] || 0;
                const hardTarget = 33;
                const remaining = Math.max(0, hardTarget - current);
                const isComplete = current >= hardTarget;
                const isSelected = key === selectedDifficulty;
                const isDisabled = isComplete;

                let barColor = 'bg-slate-800';
                if (isComplete) barColor = 'bg-blue-600';
                else if (isSelected) barColor = 'bg-orange-600';
                else if (current > 0) barColor = 'bg-green-600';

                const percentage = Math.min(100, (current / hardTarget) * 100);

                const handleClick = () => {
                    handleSelectCategory(key);
                };

                return (
                    <div
                        key={key}
                        onClick={handleClick}
                        className={`p-2 rounded transition-all cursor-pointer border ${isSelected ? 'bg-slate-800 border-orange-600 shadow-lg' : 'bg-slate-900 border-slate-800 hover:bg-slate-800/70'} ${isDisabled ? 'opacity-75' : ''}`}
                    >
                        <div className="flex justify-between items-center text-xs mb-1">
                            <span className={`font-semibold ${isComplete ? 'text-blue-300' : 'text-slate-200'}`}>{key}</span>
                            <span className={`text-[10px] font-bold ${isComplete ? 'text-blue-400' : 'text-slate-400'}`}>
                                {current} / {hardTarget} ({remaining} left)
                            </span>
                        </div>
                        <div className="w-full h-1.5 rounded overflow-hidden bg-slate-700">
                            <div className={`h-full transition-all duration-500 ${barColor}`} style={{ width: `${percentage}%` }}></div>
                        </div>
                    </div>
                );
            });

            const isBalancedSelected = selectedDifficulty === 'Balanced All';
            return (
                <div className="space-y-2">
                    <h3 className="text-sm font-bold uppercase text-slate-400 flex items-center gap-2 border-b border-slate-700/50 pb-1.5 mb-1"><Icon name="list-checks" size={14} /> Generation Target (Cap: 33)</h3>
                    {categories}
                    <button onClick={() => handleSelectCategory('Balanced All')} className={`w-full p-2 rounded transition-all cursor-pointer border mt-3 ${isBalancedSelected ? 'bg-orange-600 border-orange-400 shadow-lg' : 'bg-slate-800 border-slate-700 hover:bg-slate-700/50'}`}>
                        <div className="flex justify-center items-center text-sm font-bold gap-2">
                            <Icon name="archive" size={14} /> VIEW ALL/BULK EXPORT
                        </div>
                    </button>
                </div>
            );
        };

        const ClearConfirmationModal = ({ onConfirm, onCancel }) => (
            <div className="fixed inset-0 bg-black/90 z-[100] flex items-center justify-center p-4 backdrop-blur-sm">
                <div className="bg-slate-900 border border-slate-700 p-6 rounded-xl shadow-2xl max-w-sm w-full animate-in zoom-in-95 duration-300 space-y-4">
                    <h3 className="text-xl font-bold text-red-500 flex items-center gap-2"><Icon name="alert-triangle" size={20} /> CONFIRM DATABASE WIPE</h3>
                    <p className="text-sm text-slate-300">This action will permanently delete all accepted questions saved in the database for this application. Are you sure you want to proceed?</p>
                    <div className="flex justify-end gap-3">
                        <button onClick={onCancel} className="px-4 py-2 text-sm rounded bg-slate-700 hover:bg-slate-600 text-white transition-colors">Cancel</button>
                        <button onClick={onConfirm} className="px-4 py-2 text-sm rounded bg-red-600 hover:bg-red-700 text-white font-bold transition-colors">Wipe All Data</button>
                    </div>
                </div>
            </div>
        );

        const FilterButton = ({ mode, current, setFilter, label, count, color }) => {
            const isActive = mode === current;
            const baseClasses = "px-3 py-1 text-xs font-medium rounded transition-all flex items-center gap-1";
            let activeClasses = "bg-orange-600 text-white shadow-md shadow-orange-900/50";
            let inactiveClasses = "bg-slate-800 text-slate-400 hover:bg-slate-700/50";
            if (mode === 'accepted' && !isActive) inactiveClasses = "bg-green-900/20 text-green-400 hover:bg-green-900/30";
            if (mode === 'rejected' && !isActive) inactiveClasses = "bg-red-900/20 text-red-400 hover:bg-red-900/30";
            if (mode === 'pending' && !isActive) inactiveClasses = "bg-yellow-900/20 text-yellow-400 hover:bg-yellow-900/30";
            return (
                <button onClick={() => setFilter(mode)} className={`${baseClasses} ${isActive ? activeClasses : inactiveClasses}`}>
                    <Icon name={mode === 'accepted' ? 'check' : mode === 'rejected' ? 'x' : mode === 'pending' ? 'clock' : 'list'} size={12} />
                    {label} <span className="text-[10px] bg-slate-950/50 px-1.5 rounded-full">{count}</span>
                </button>
            );
        };


        const App = () => {
            const [appMode, setAppMode] = useState('landing'); // 'landing', 'create', 'review'
            const [db, setDb] = useState(null);
            const [auth, setAuth] = useState(null);
            const [userId, setUserId] = useState(null);
            const [isAuthReady, setIsAuthReady] = useState(false);
            const [isCloudReady, setIsCloudReady] = useState(false); // Track actual cloud connection status
            const [showClearModal, setShowClearModal] = useState(false);
            const [showExportMenu, setShowExportMenu] = useState(false);
            const [translationProgress, setTranslationProgress] = useState(0);

            const [filterByCreator, setFilterByCreator] = useState(false);

            const TARGET_TOTAL = 200;
            const TARGET_PER_CATEGORY = 33;

            // --- ENVIRONMENT AND API KEY STATUS CHECK ---
            // If __app_id is defined, assume we are in the Canvas environment and the API key will be auto-injected.
            const isInternalEnvironment = typeof __app_id !== 'undefined';

            const [config, setConfig] = useState(() => {
                const saved = localStorage.getItem('ue5_gen_config');
                // ADDED: apiKey to defaults
                const defaults = { discipline: 'Technical Art', batchSize: '6', difficulty: 'Easy MC', language: 'English', creatorName: '', reviewerName: '', apiKey: '' };
                const constInitialConfig = saved ? { ...defaults, ...JSON.parse(saved) } : defaults;
                // Ensure creatorName and reviewerName defaults are restored if removed from storage
                constInitialConfig.creatorName = constInitialConfig.creatorName || '';
                constInitialConfig.reviewerName = constInitialConfig.reviewerName || '';
                constInitialConfig.apiKey = constInitialConfig.apiKey || ''; // Ensure API key is loaded
                if (constInitialConfig.difficulty === 'Balanced All') constInitialConfig.difficulty = 'Easy MC';
                return constInitialConfig;
            });

            // Computed values for API key status and effective key
            const isApiReady = isInternalEnvironment || (config.apiKey && config.apiKey.length > 5);
            const effectiveApiKey = isInternalEnvironment ? "" : config.apiKey;

            // Map of UniqueID -> List of Question Objects (all languages)
            const [allQuestionsMap, setAllQuestionsMap] = useState(new Map());

            const [questions, setQuestions] = useState(() => {
                const saved = localStorage.getItem('ue5_gen_questions');
                return saved ? JSON.parse(saved) : [];
            });

            const [files, setFiles] = useState([]);
            const [status, setStatus] = useState('');
            const [isGenerating, setIsGenerating] = useState(false);
            const [isDetecting, setIsDetecting] = useState(false);
            const [isProcessing, setIsProcessing] = useState(false);
            const [showNameModal, setShowNameModal] = useState(false);

            const [searchTerm, setSearchTerm] = useState('');
            const [filterMode, setFilterMode] = useState('pending');
            const [historicalQuestions, setHistoricalQuestions] = useState([]);
            const [showHistory, setShowHistory] = useState(false);
            const fileInputRef = useRef(null);

            // Recompute allQuestionsMap whenever session or historical questions change
            useEffect(() => {
                const combined = [...questions, ...historicalQuestions];
                const newMap = new Map();
                combined.forEach(q => {
                    const id = q.uniqueId;
                    if (!newMap.has(id)) newMap.set(id, []);
                    newMap.get(id).push(q);
                });
                setAllQuestionsMap(newMap);
            }, [questions, historicalQuestions]);

            // Recompute the translation map (set of available languages per question ID)
            const translationMap = useMemo(() => {
                const map = new Map();
                Array.from(allQuestionsMap.keys()).forEach(uniqueId => {
                    const variants = allQuestionsMap.get(uniqueId);
                    const langSet = new Set(variants.map(v => v.language || 'English'));
                    map.set(uniqueId, langSet);
                });
                return map;
            }, [allQuestionsMap]);


            const showMessage = useCallback((msg, duration = 3000) => {
                setStatus(msg);
                setTimeout(() => setStatus(''), duration);
            }, []);

            // Helper to safely add new questions without creating duplicates in React state
            const addQuestionsToState = (newItems, isHistory = false) => {
                const targetSet = isHistory ? setHistoricalQuestions : setQuestions;
                targetSet(prev => {
                    const existingIds = new Set(prev.map(p => p.id));
                    const uniqueNew = newItems.filter(item => !existingIds.has(item.id));
                    return [...prev, ...uniqueNew];
                });
            };

            const approvedCounts = useMemo(() => {
                const counts = CATEGORY_KEYS.reduce((acc, key) => ({ ...acc, [key]: 0 }), {});
                const countedIds = new Set();

                Array.from(allQuestionsMap.values()).forEach(variants => {
                    const baseQ = variants.find(v => (v.language || 'English') === 'English') || variants[0];

                    if (baseQ && baseQ.status === 'accepted' && !countedIds.has(baseQ.uniqueId)) {
                        const typeAbbrev = baseQ.type === 'True/False' ? 'T/F' : 'MC';
                        const key = `${baseQ.difficulty} ${typeAbbrev}`;
                        if (counts.hasOwnProperty(key)) {
                            counts[key]++;
                            countedIds.add(baseQ.uniqueId);
                        }
                    }
                });
                return counts;
            }, [allQuestionsMap]);

            const approvedCount = questions.filter(q => q.status !== 'rejected').length;
            const rejectedCount = questions.filter(q => q.status === 'rejected').length;
            const pendingCount = questions.length - approvedCount - rejectedCount;

            const isTargetMet = useMemo(() => {
                if (config.difficulty === 'Balanced All') return false;
                const currentCount = approvedCounts[config.difficulty];
                return currentCount >= TARGET_PER_CATEGORY;
            }, [config.difficulty, approvedCounts]);

            const maxBatchSize = useMemo(() => {
                if (config.difficulty === 'Balanced All') {
                    const maxRemaining = Math.max(...CATEGORY_KEYS.map(key => TARGET_PER_CATEGORY - approvedCounts[key]));
                    if (maxRemaining <= 0) return 0;
                    return Math.min(30, Math.floor(TARGET_TOTAL / 6) * 6);
                } else {
                    const remaining = TARGET_PER_CATEGORY - approvedCounts[config.difficulty];
                    return Math.min(33, Math.max(0, remaining));
                }
            }, [config.difficulty, approvedCounts]);

            useEffect(() => {
                if (maxBatchSize > 0 && config.difficulty !== 'Balanced All') {
                    const recommendedSize = Math.max(1, Math.min(10, Math.floor(maxBatchSize / 2)));
                    setConfig(prev => ({ ...prev, batchSize: recommendedSize.toString() }));
                } else if (config.difficulty === 'Balanced All') {
                    setConfig(prev => ({ ...prev, batchSize: Math.max(6, Math.min(12, maxBatchSize)).toString() }));
                } else if (maxBatchSize === 0 && config.difficulty !== 'Balanced All') {
                    setConfig(prev => ({ ...prev, batchSize: '0' }));
                }
            }, [config.difficulty, maxBatchSize]);

            useEffect(() => { if (!config.creatorName) setShowNameModal(true); }, []);
            useEffect(() => { localStorage.setItem('ue5_gen_config', JSON.stringify(config)); }, [config]);
            useEffect(() => localStorage.setItem('ue5_gen_questions', JSON.stringify(questions)), [questions]);

            const QUESTION_COLLECTION = "generatedQuestions";

            useEffect(() => {
                const checkFirebase = setInterval(() => {
                    if (typeof window.Firebase !== 'undefined' && window.isFirebaseLoaded) {
                        clearInterval(checkFirebase);
                        initFirebase();
                    }
                }, 100);

                const initFirebase = async () => {
                    try {
                        // Only initialize if config exists (cloud mode)
                        if (typeof __firebase_config !== 'undefined') {
                            const firebaseConfig = JSON.parse(__firebase_config);
                            const app = window.Firebase.initializeApp(firebaseConfig);
                            const newDb = window.Firebase.getFirestore(app);
                            const newAuth = window.Firebase.getAuth(app);

                            setDb(newDb);
                            setAuth(newAuth);

                            // Robust Auth Pattern from Demo
                            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                                await window.Firebase.signInWithCustomToken(newAuth, __initial_auth_token);
                            } else {
                                await window.Firebase.signInAnonymously(newAuth);
                            }

                            window.Firebase.onAuthStateChanged(newAuth, (user) => {
                                if (user) {
                                    setUserId(user.uid);
                                    setIsCloudReady(true); // Mark as successfully connected to cloud
                                } else {
                                    setUserId(null);
                                    setIsCloudReady(false);
                                }
                                setIsAuthReady(true);
                            });
                        } else {
                            // Local mode fallback
                            console.log("No cloud config found. Running in Local Mode.");
                            setIsAuthReady(true);
                            setIsCloudReady(false);
                        }
                    } catch (e) {
                        console.error("Firebase Initialization Failed (Defaulting to Local Mode):", e);
                        setIsAuthReady(true);
                        setIsCloudReady(false);
                    }
                };

                return () => clearInterval(checkFirebase);
            }, []);

            // Modified: Use onSnapshot for REAL-TIME updates
            useEffect(() => {
                if (isAuthReady && isCloudReady && db) {
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    const collectionPath = window.Firebase.collection(db, `artifacts/${appId}/public/data/${QUESTION_COLLECTION}`);

                    // Set up listener
                    const unsubscribe = window.Firebase.onSnapshot(collectionPath, (snapshot) => {
                        const loadedHistory = snapshot.docs.map(doc => {
                            const d = doc.data();
                            return {
                                ...d,
                                id: d.id || d.uniqueId, // Ensure ID exists
                                uniqueId: d.uniqueId || d.id,
                                status: 'accepted' // Anything in DB is treated as accepted history
                            };
                        });

                        // Sort by dateAdded if available, newest first
                        loadedHistory.sort((a, b) => new Date(b.dateAdded || 0) - new Date(a.dateAdded || 0));

                        setHistoricalQuestions(loadedHistory);
                        // If this is the first load, maybe show a message? 
                        // showMessage("Cloud Sync Active", 2000); 
                    }, (error) => {
                        console.error("Sync Error:", error);
                        setIsCloudReady(false); // Downgrade to local if sync fails
                    });

                    return () => unsubscribe();
                }
            }, [isAuthReady, isCloudReady, db]);

            const handleDeleteAllQuestions = async () => {
                setShowClearModal(false);
                if (!db || !isCloudReady) { showMessage("Local Mode: Cleared browser storage.", 3000); setQuestions([]); setHistoricalQuestions([]); return; }

                setStatus('Wiping cloud database...');
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const collectionPath = window.Firebase.collection(db, `artifacts/${appId}/public/data/${QUESTION_COLLECTION}`);

                try {
                    const snapshot = await window.Firebase.getDocs(collectionPath);
                    if (snapshot.empty) {
                        setStatus('Database already empty.');
                        setQuestions([]);
                        return;
                    }

                    const CHUNK_SIZE = 500;
                    const chunks = [];
                    const docs = snapshot.docs;

                    for (let i = 0; i < docs.length; i += CHUNK_SIZE) {
                        chunks.push(docs.slice(i, i + CHUNK_SIZE));
                    }

                    for (const chunk of chunks) {
                        const batch = window.Firebase.writeBatch(db);
                        chunk.forEach(doc => {
                            batch.delete(doc.ref);
                        });
                        await batch.commit();
                    }

                    setStatus(`Cloud wiped successfully.`);
                    setQuestions([]);
                    // historicalQuestions will auto-clear via onSnapshot listener

                } catch (e) {
                    console.error("Database deletion failed:", e);
                    showMessage(`Failed to clear database: ${e.message}`, 5000);
                }
            };

            const checkAndStoreQuestions = async (newQuestions) => {
                // If not cloud ready, just return the questions (they stay in local state)
                if (!db || !isCloudReady) { return newQuestions; }

                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const collectionPath = window.Firebase.collection(db, `artifacts/${appId}/public/data/${QUESTION_COLLECTION}`);
                const uniqueQuestions = [];
                const generatedQuestionsMap = new Map();

                // Deduplication logic
                newQuestions.forEach(q => {
                    const cleanQuestion = stripHtmlTags(q.question);
                    generatedQuestionsMap.set(cleanQuestion, q);
                });

                setStatus(`Syncing ${newQuestions.length} questions to cloud...`);

                try {
                    // We fetch current state once to check duplicates before writing
                    // (Optimization: In a massive DB, you might skip this and rely on unique IDs, 
                    // but here we want to avoid overwriting existing with same content if IDs differ)
                    const snapshot = await window.Firebase.getDocs(collectionPath);
                    const existingKeys = new Set(snapshot.docs.map(doc => `${doc.data().uniqueId}_${doc.data().language || 'English'}`));

                    const batchWrites = [];
                    let duplicateCount = 0;

                    generatedQuestionsMap.forEach((q, cleanQuestion) => {
                        const key = `${q.uniqueId}_${q.language || 'English'}`;
                        if (existingKeys.has(key)) {
                            duplicateCount++;
                        } else {
                            uniqueQuestions.push(q);
                            const docId = `${q.uniqueId}_${q.language || 'English'}`;
                            const docRef = window.Firebase.doc(collectionPath, docId);
                            batchWrites.push(window.Firebase.setDoc(docRef, {
                                id: q.id.toString(),
                                uniqueId: q.uniqueId,
                                cleanQuestion: cleanQuestion,
                                question: q.question,
                                discipline: q.discipline,
                                type: q.type,
                                difficulty: q.difficulty,
                                options: q.options,
                                correct: q.correct,
                                sourceUrl: q.sourceUrl,
                                sourceExcerpt: q.sourceExcerpt,
                                dateAdded: q.dateAdded || new Date().toISOString(),
                                creatorName: config.creatorName,
                                reviewerName: config.reviewerName,
                                language: q.language || config.language
                            }));
                        }
                    });

                    if (batchWrites.length > 0) {
                        await Promise.all(batchWrites);
                        setStatus(`Saved ${batchWrites.length} items to Cloud.`);
                    } else {
                        setStatus(`Cloud sync complete (No new items).`);
                    }
                    return uniqueQuestions;
                } catch (e) {
                    console.error("Firestore operation failed:", e);
                    setStatus(`Cloud Error: Saved locally only.`);
                    return newQuestions;
                }
            };

            const loadHistory = async () => {
                // Replaced by useEffect onSnapshot, but kept for manual trigger consistency
                if (!db || !isCloudReady) {
                    // If local, historicalQuestions is just empty or whatever was loaded from local storage if we implemented that
                    setHistoricalQuestions([]);
                    return;
                }
                setShowHistory(true);
                // The useEffect will handle the actual fetching
            };

            const handleToggleHistory = () => {
                if (showHistory) {
                    setShowHistory(false);
                    // Don't clear historicalQuestions here, let them stay cached in background
                    setFilterMode('pending');
                } else {
                    setSearchTerm('');
                    // loadHistory(); // Not needed, useEffect handles it
                    setShowHistory(true);
                    setFilterMode('all');
                }
            };

            const handleSyncToDatabase = async () => {
                const validQuestions = questions.filter(q => q.status !== 'rejected');
                if (validQuestions.length === 0) {
                    showMessage("No valid questions to sync.", 3000);
                    return;
                }
                await checkAndStoreQuestions(validQuestions);
            };

            const handleLanguageSwitch = (lang) => {
                setConfig(prev => ({ ...prev, language: lang }));
            };

            const handleChange = (e) => {
                const { name, value } = e.target;
                if (name === 'batchSize' && config.difficulty === 'Balanced All') {
                    const num = parseInt(value);
                    if (num % 6 !== 0) showMessage("For Balanced All mode, the batch size should be a multiple of 6 (e.g., 6, 12, 18) for an even distribution.", 3000);
                }
                setConfig(prev => ({ ...prev, [name]: value }));
                // If user changes language in dropdown, update global language filter
                if (name === 'language') {
                    handleLanguageSwitch(value);
                }
            };

            // MODIFIED: Set both creatorName and reviewerName to the entered name
            const handleNameSave = (name) => {
                setConfig(prev => ({ ...prev, creatorName: name, reviewerName: name }));
                setShowNameModal(false);
            };

            const handleFileChange = (e) => {
                const newFiles = Array.from(e.target.files);
                const allowedTypes = ['text/', 'application/json', 'application/javascript', 'application/xml', 'application/csv'];
                const allowedExtensions = ['.txt', '.md', '.csv', '.json', '.js', '.html', '.css', '.xml', '.py', '.cpp', '.h', '.cs'];
                const validFiles = newFiles.filter(file => {
                    const isTextType = file.type.startsWith('text/') || allowedTypes.includes(file.type);
                    const hasTextExt = allowedExtensions.some(ext => file.name.toLowerCase().endsWith(ext));
                    return isTextType || hasTextExt;
                });

                const csvFiles = validFiles.filter(f => f.name.toLowerCase().endsWith('.csv'));
                const otherFiles = validFiles.filter(f => !f.name.toLowerCase().endsWith('.csv'));

                if (csvFiles.length > 0) {
                    csvFiles.forEach(file => {
                        const reader = new FileReader();
                        reader.onload = async (ev) => {
                            const content = ev.target.result;
                            const importedQuestions = [];
                            const lines = content.split('\n');
                            const header = lines[0] ? lines[0].split(FIELD_DELIMITER) : [];

                            const fileName = file.name;
                            let fileLanguage = null;
                            Object.keys(LANGUAGE_FLAGS).forEach(lang => {
                                const safeLang = lang.replace(/ /g, '_');
                                if (fileName.toLowerCase().includes(safeLang.toLowerCase()) || fileName.toLowerCase().includes(lang.toLowerCase())) {
                                    fileLanguage = lang;
                                }
                            });

                            if (header.length > 5 && header[0].includes('ID') && header[2].includes('Discipline')) {
                                lines.slice(1).forEach((line, idx) => {
                                    if (!line.trim()) return;
                                    const cols = parseCSVLine(line);
                                    if (cols.length < 10) return;
                                    const uniqueId = cols[1] && cols[1].length > 5 ? cols[1] : crypto.randomUUID();
                                    importedQuestions.push({
                                        id: Date.now() + idx + Math.random(),
                                        uniqueId: uniqueId,
                                        discipline: cols[2] || "Imported",
                                        type: cols[3] || "Multiple Choice",
                                        difficulty: cols[4] || "Easy",
                                        question: cols[5] || "",
                                        options: { A: cols[6] || "", B: cols[7] || "", C: cols[8] || "", D: cols[9] || "" },
                                        correct: cols[10] || "",
                                        dateAdded: cols[11] || new Date().toISOString(),
                                        sourceUrl: cols[12] || "",
                                        sourceExcerpt: cols[13] || "",
                                        creatorName: cols[14] || config.creatorName || "",
                                        reviewerName: cols[15] || "",
                                        status: 'accepted',
                                        language: cols[16] || fileLanguage || "English"
                                    });
                                });
                                if (importedQuestions.length > 0) {
                                    addQuestionsToState(importedQuestions, showHistory);
                                    await checkAndStoreQuestions(importedQuestions);
                                    showMessage(`Imported ${importedQuestions.length} questions from CSV.`, 4000);
                                    if (showHistory) {
                                        loadHistory();
                                    }
                                }
                            } else {
                                setFiles(prev => [...prev, { name: file.name, content: content, size: file.size }]);
                            }
                        };
                        reader.readAsText(file);
                    });
                }
                if (otherFiles.length > 0) {
                    otherFiles.forEach(file => {
                        const reader = new FileReader();
                        reader.onload = (ev) => { setFiles(prev => [...prev, { name: file.name, content: ev.target.result, size: file.size }]); };
                        reader.readAsText(file);
                    });
                }
                if (validFiles.length < newFiles.length) showMessage("Skipped non-text files (images/binaries). Upload text-based files only.", 5000);
            };

            const removeFile = (index) => { setFiles(prev => prev.filter((_, i) => i !== index)); };

            const getFileContext = () => {
                const MAX_FILE_CONTENT_LENGTH = 10000; // Reduced to mitigate MAX_TOKENS issues
                let fileContext = "";
                if (files.length > 0) {
                    fileContext = "\n\n### ATTACHED LOCAL SOURCE FILES:\n";
                    files.forEach(f => {
                        const content = f.content.substring(0, MAX_FILE_CONTENT_LENGTH);
                        const isTruncated = f.content.length > MAX_FILE_CONTENT_LENGTH;
                        fileContext += `\n--- START FILE: ${f.name} (Size: ${f.size} bytes) ---\n`;
                        fileContext += content;
                        if (isTruncated) fileContext += `\n[... File content truncated to ${MAX_FILE_CONTENT_LENGTH} characters for prompt size safety]`;
                        fileContext += "\n--- END FILE ---\n";
                    });
                }
                return fileContext;
            };

            const constructSystemPrompt = () => {
                let batchNum = parseInt(config.batchSize) || 6;
                let easyCount = 0; let mediumCount = 0; let hardCount = 0;
                let targetType = 'Multiple Choice and True/False';
                let mcCount = 0; let tfCount = 0;
                const [difficulty, type] = config.difficulty.split(' ');
                if (difficulty === 'Balanced') {
                    if (batchNum % 6 !== 0) batchNum = Math.ceil(batchNum / 6) * 6;
                    const countPerCategory = batchNum / 6;
                    easyCount = countPerCategory; mediumCount = countPerCategory; hardCount = countPerCategory;
                    targetType = 'Multiple Choice and True/False'; mcCount = countPerCategory * 3; tfCount = countPerCategory * 3;
                } else {
                    if (difficulty === 'Easy') easyCount = batchNum; else if (difficulty === 'Medium') mediumCount = batchNum; else if (difficulty === 'Hard') hardCount = batchNum;
                    if (type === 'MC') { targetType = 'Multiple Choice ONLY'; mcCount = batchNum; } else if (type === 'T/F') { targetType = 'True/False ONLY'; tfCount = batchNum; }
                }
                const difficultyPrompt = (difficulty === 'Balanced') ? `Generate approximately ${easyCount} Easy, ${mediumCount} Medium, and ${hardCount} Hard questions. Aim for ${mcCount} Multiple Choice questions and ${tfCount} True/False questions for a balanced batch.` : `Generate exactly ${batchNum} questions of difficulty: ${difficulty}.`;
                return `
## Universal UE5 Scenario-Based Question Generator â€” Gemini Version
Role: You are a senior Unreal Engine 5 technical writer. Create short, clear, scenario-driven questions in Simplified Technical English (STE).
**FORMATTING INSTRUCTION:** You MUST enclose key technical concepts (like Nanite, Lumen, Blueprints, Virtual Shadow Maps) in HTML bold tags (e.g., <b>Nanite</b>) in the Question and Answer columns.
Discipline: ${config.discipline}
Target Language: ${config.language}
Question Type: ${targetType}
**LANGUAGE STRICTNESS:** Output ONLY in ${config.language}. Do NOT provide bilingual text.
Question Format:
| ID | Discipline | Type | Difficulty | Question | Answer | OptionA | OptionB | OptionC | OptionD | CorrectLetter | SourceURL | SourceExcerpt |
- ID starts at 1.
- Difficulty levels: Easy / Medium / Hard.
- For True/False questions: OptionA=TRUE, OptionB=FALSE. CorrectLetter=A/B.
- **CRITICAL RULE:** True/False questions must be a SINGLE assertion.
- **TYPE RULE:** If Question Type is 'Multiple Choice ONLY', do NOT generate True/False questions. If Question Type is 'True/False ONLY', do NOT generate Multiple Choice questions.
Sourcing:
1. Official Epic Games Documentation (dev.epicgames.com/documentation)
3. Attached Local Files
**FORBIDDEN SOURCES:** Do NOT use forums, Reddit, community wikis, or external video platforms like YouTube.
Output:
- **OUTPUT INSTRUCTION:** ${difficultyPrompt}
${getFileContext()}
`;
            };

            const handleGenerate = async () => {
                if (!config.creatorName) { showMessage("Please enter your Creator Name to start generating.", 5000); setShowNameModal(true); return; }
                if (!isApiReady) { showMessage("API key is required for generation. Please enter it in the settings panel.", 5000); return; }

                if (config.difficulty !== 'Balanced All' && isTargetMet) { showMessage(`Quota met for ${config.difficulty}! Change difficulty/type or discipline to continue.`, 5000); return; }

                setIsGenerating(true); setShowHistory(false); setStatus('Drafting Scenarios...');
                const systemPrompt = constructSystemPrompt();
                const userPrompt = `Generate ${config.batchSize} scenario-based questions for ${config.discipline} in ${config.language}. Focus: ${config.difficulty}. Ensure links work for UE 5.7 or latest available.`;
                try {
                    // Pass effectiveKey (which is "" if internal, or user's key if external)
                    const text = await generateContent(effectiveApiKey, systemPrompt, userPrompt, setStatus);
                    let newQuestions = parseQuestions(text);
                    if (newQuestions.length === 0) throw new Error("Failed to parse generated questions.");
                    // NOTE: We add 'language' property to newly generated questions
                    const taggedQuestions = newQuestions.map(q => ({ ...q, language: config.language }));
                    const uniqueNewQuestions = await checkAndStoreQuestions(taggedQuestions);

                    // SAFE STATE UPDATE
                    addQuestionsToState(uniqueNewQuestions, false);

                    setStatus('');
                } catch (err) { console.error(err); setStatus('Error'); showMessage(`Generation Error: ${err.message}. Please try again.`, 10000); } finally { setIsGenerating(false); }
            };

            const handleDetectTopics = async () => {
                if (files.length === 0) return;
                if (!isApiReady) { showMessage("API key is required for detection. Please enter it in the settings panel.", 5000); return; }

                setIsDetecting(true); setStatus('Scanning...');
                const prompt = `Analyze content. Identify 3 prominent technical disciplines. Return ONLY comma-separated list. ${getFileContext()}`;
                try {
                    // Pass effectiveKey
                    const detected = await generateContent(effectiveApiKey, "Technical Analyst", prompt, setStatus);
                    setConfig(prev => ({ ...prev, discipline: detected.split(',')[0].trim() }));
                    setStatus('Detected'); setTimeout(() => setStatus(''), 2000);
                } catch (err) { setStatus('Failed'); } finally { setIsDetecting(false); }
            };

            const handleTranslate = async (fromLang, toLang) => {
                if (questions.length === 0) return;
                if (!isApiReady) { showMessage("API key is required for translation. Please enter it in the settings panel.", 5000); return; }

                setIsProcessing(true); setStatus(`Translating to ${toLang}...`);
                let rawTable = "| ID | Discipline | Type | Difficulty | Question | Answer | OptionA | OptionB | OptionC | OptionD | CorrectLetter | SourceURL | SourceExcerpt |\n|---|---|---|---|---|---|---|---|---|---|---|---|---|\n";
                questions.forEach((q, i) => {
                    const opts = q.options || {};
                    rawTable += `| ${i + 1} | ${stripHtmlTags(q.discipline)} | ${stripHtmlTags(q.type)} | ${stripHtmlTags(q.difficulty)} | ${stripHtmlTags(q.question)} | | ${stripHtmlTags(opts.A || '')} | ${stripHtmlTags(opts.B || '')} | ${stripHtmlTags(opts.C || '')} | ${stripHtmlTags(opts.D || '')} | ${q.correct} | ${stripHtmlTags(q.sourceUrl)} | ${stripHtmlTags(q.sourceExcerpt)} |\n`;
                });
                const prompt = `
                You are a professional technical translator for Unreal Engine 5 documentation. Translate the provided Markdown table from ${fromLang} to ${toLang}.
                CRITICAL INSTRUCTIONS:
                1. Preserve the exact Markdown table structure, including the pipe characters (|) and the header row.
                2. Translate ONLY the following columns: Question, OptionA, OptionB, OptionC, OptionD, and SourceExcerpt.
                3. DO NOT translate: ID, Discipline, Type, Difficulty, Answer (column 6), CorrectLetter, and SourceURL.
                4. **Translate ALL rows. Do not summarize or skip any rows.**
                5. Ensure you use standard half-width pipe characters (|) for column separators, not full-width (ï½œ).
                Content: ${rawTable}
                `;
                try {
                    // Pass effectiveKey
                    const text = await generateContent(effectiveApiKey, "You are a translator.", prompt, setStatus);
                    const translatedQuestions = parseQuestions(text);
                    if (translatedQuestions.length > 0) {
                        setQuestions(translatedQuestions.map((tq, i) => ({ ...tq, id: questions[i]?.id || tq.id, status: questions[i]?.status || 'pending' })));
                        setStatus('Translated');
                        // Force language update
                        handleLanguageSwitch(toLang);
                    }
                } catch (e) { setStatus('Fail'); } finally { setIsProcessing(false); }
            };

            // NEW: Handle single question translation (used by flags/codes)
            const handleTranslateSingle = async (q, targetLang) => {
                if (!isApiReady) { showMessage("API key is required for translation. Please enter it in the settings panel.", 5000); return; }

                setIsProcessing(true);
                setStatus(`Translating question to ${targetLang}...`);

                const rawTable = `| ID | Discipline | Type | Difficulty | Question | Answer | OptionA | OptionB | OptionC | OptionD | CorrectLetter | SourceURL | SourceExcerpt |\n|---|---|---|---|---|---|---|---|---|---|---|---|---|\n| 1 | ${q.discipline} | ${q.type} | ${q.difficulty} | ${q.question} | | ${q.options.A} | ${q.options.B} | ${q.options.C || ''} | ${q.options.D || ''} | ${q.correct} | ${q.sourceUrl} | ${q.sourceExcerpt} |`;

                const prompt = `Translate this single row from ${q.language || 'English'} to ${targetLang}. Keep format EXACT. \n${rawTable}`;

                try {
                    // Pass effectiveKey
                    const text = await generateContent(effectiveApiKey, "Translator", prompt, setStatus);
                    const translatedQs = parseQuestions(text);
                    if (translatedQs.length > 0) {
                        const tq = translatedQs[0];
                        const newQuestion = {
                            ...tq,
                            id: Date.now(),
                            uniqueId: q.uniqueId,
                            discipline: q.discipline,
                            type: q.type,
                            difficulty: q.difficulty,
                            language: targetLang,
                            status: 'accepted',
                            dateAdded: new Date().toISOString()
                        };

                        await checkAndStoreQuestions([newQuestion]);
                        addQuestionsToState([newQuestion], showHistory);

                        // Switch the entire view to the new translated language
                        handleLanguageSwitch(targetLang);

                        showMessage(`Translated to ${targetLang} and saved.`, 3000);
                    }
                } catch (e) {
                    console.error(e);
                    setStatus('Translation Failed');
                } finally {
                    setIsProcessing(false);
                }
            };

            const handleExplain = async (q) => {
                if (!isApiReady) { showMessage("API key is required for explanation. Please enter it in the settings panel.", 5000); return; }

                setIsProcessing(true); setStatus('Explaining...');
                const prompt = `Explain WHY the answer is correct in simple terms: "${q.question}" Answer: "${q.correct === 'A' ? q.options.A : q.options.B}"`;
                try {
                    // Pass effectiveKey
                    const exp = await generateContent(effectiveApiKey, "Technical Assistant", prompt, setStatus);
                    const targetSet = showHistory ? setHistoricalQuestions : setQuestions;
                    targetSet(prev => prev.map(i => i.id === q.id ? { ...i, explanation: exp } : i));
                    setStatus('');
                } catch (e) { setStatus('Fail'); } finally { setIsProcessing(false); }
            };

            const handleVariate = async (q) => {
                if (!isApiReady) { showMessage("API key is required for creation. Please enter it in the settings panel.", 5000); return; }

                setIsProcessing(true); setStatus('Creating variations...');
                const sys = constructSystemPrompt();
                const prompt = `Generate 2 NEW unique questions based on: "${q.question}". Output in Markdown Table.`;
                try {
                    // Pass effectiveKey
                    const text = await generateContent(effectiveApiKey, sys, prompt, setStatus);
                    const newQs = parseQuestions(text);
                    if (newQs.length > 0) {
                        const uniqueNewQuestions = await checkAndStoreQuestions(newQs);
                        addQuestionsToState(uniqueNewQuestions, showHistory);

                        if (showHistory) showMessage(`Added ${uniqueNewQuestions.length} variations to Session view.`, 4000);
                        else showMessage(`Added ${uniqueNewQuestions.length} new variations.`, 3000);
                    }
                } catch (e) { setStatus('Fail'); } finally { setIsProcessing(false); }
            };

            const handleCritique = async (q) => {
                if (!isApiReady) { showMessage("API key is required for critique. Please enter it in the settings panel.", 5000); return; }

                setIsProcessing(true); setStatus('Critiquing...');
                const questionDetails = `Question: ${q.question}\nDiscipline: ${q.discipline}\nDifficulty: ${q.difficulty}\nCorrect Answer: ${q.correct}: ${q.options[q.correct] || 'N/A'}`;
                const systemPrompt = `You are a Technical Writing Editor specialized in Unreal Engine 5 content. Analyze this REJECTED quiz question and provide actionable, numbered suggestions for improvement. Focus on: Clarity and technical accuracy. Output ONLY a brief, numbered list of 3-5 concrete suggestions.`;
                try {
                    // Pass effectiveKey
                    const critiqueText = await generateContent(effectiveApiKey, systemPrompt, `Critique and suggest fixes for the following rejected question:\n${questionDetails}`, setStatus);
                    const targetSet = showHistory ? setHistoricalQuestions : setQuestions;
                    targetSet(prev => prev.map(i => i.id === q.id ? { ...i, critique: critiqueText } : i));
                    showMessage('Critique Ready', 3000);
                } catch (e) { setStatus('Fail'); } finally { setIsProcessing(false); }
            };

            const downloadFile = (data, filename) => {
                const BOM = "\uFEFF";
                const finalType = 'text/csv;charset=utf-8;';
                const blob = new Blob([BOM + data], { type: finalType });
                const url = URL.createObjectURL(blob);
                const link = document.createElement("a");
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            };

            const getCSVContent = (validQuestions, creatorName, reviewerName, includeHeaders = true) => {
                const headers = ["ID", "Question ID", "Discipline", "Type", "Difficulty", "Question", "Option A", "Option B", "Option C", "Option D", "Correct Answer", "Generation Date", "Source URL", "Source Excerpt", "Creator", "Reviewer", "Language"];
                let csvContent = includeHeaders ? headers.map(safe).join(FIELD_DELIMITER) + '\n' : '';
                const generationDate = formatDate(new Date());
                validQuestions.forEach((row, i) => {
                    const cleanedSourceUrl = row.sourceUrl && !row.sourceUrl.includes("grounding-api") ? row.sourceUrl : "";
                    const o = row.options || {};
                    const rowData = [(i + 1).toString(), row.uniqueId, row.discipline, row.type, row.difficulty, row.question, o.A, o.B, o.C, o.D || "", row.correct, generationDate, cleanedSourceUrl, row.sourceExcerpt, creatorName, reviewerName, row.language || "English"];
                    csvContent += rowData.map(safe).join(FIELD_DELIMITER) + '\n';
                });
                return csvContent;
            };

            const handleExportByGroup = () => {
                const sourceList = showHistory ? historicalQuestions : questions;
                const valid = sourceList.filter(q => q.status !== 'rejected');

                if (valid.length === 0) { showMessage("No accepted questions to export.", 3000); return; }

                // NEW GROUPING: Language, Discipline, Difficulty, Type
                const groupedData = valid.reduce((acc, q) => {
                    const typeAbbrev = q.type === 'True/False' ? 'T/F' : 'MC';
                    // Use a unique key combining all segmentation requirements
                    const key = `${q.language || 'English'}_${q.discipline}_${q.difficulty}_${typeAbbrev}`;
                    if (!acc[key]) acc[key] = [];
                    acc[key].push(q);
                    return acc;
                }, {});

                let filesGenerated = 0;
                const exportDate = new Date();
                const datePart = formatDate(exportDate).replace(/-/g, '');

                Object.keys(groupedData).forEach(groupKey => {
                    const groupQuestions = groupedData[groupKey];
                    const csvContent = getCSVContent(groupQuestions, config.creatorName, config.reviewerName);

                    // Format filename: Language_Discipline_Difficulty_Type_Date.csv
                    const fileNameParts = groupKey.replace(/ & /g, '_').replace(/ /g, '_');
                    const filename = `${fileNameParts}_${datePart}.csv`;

                    downloadFile(csvContent, filename);
                    filesGenerated++;
                });

                showMessage(`Exported ${filesGenerated} segmented files.`, 7000);
                setShowExportMenu(false);
            };

            const handleExportCurrentTarget = () => {
                const sourceList = showHistory ? historicalQuestions : questions;

                const targetString = config.difficulty; // e.g., "Easy MC"

                const [targetDiff, targetTypeAbbrev] = targetString.split(' ');
                const targetType = targetTypeAbbrev === 'MC' ? 'Multiple Choice' : 'True/False';

                // Filter by current language, discipline, difficulty, and type
                const valid = sourceList.filter(q =>
                    q.status !== 'rejected' &&
                    (q.language || 'English') === config.language && // Include language filter
                    q.discipline === config.discipline &&
                    q.difficulty === targetDiff &&
                    q.type === targetType
                );

                if (valid.length === 0) {
                    showMessage(`No accepted questions found for target: ${config.language} - ${targetString}`, 3000);
                    return;
                }

                const typePart = targetString.replace(/\s/g, '_');
                const disciplinePart = config.discipline.replace(/\s/g, '_');
                const datePart = new Date().toISOString().split('T')[0].replace(/-/g, '');
                const langPart = (config.language || 'English').replace(/ /g, '_');

                const csvContent = getCSVContent(valid, config.creatorName, config.reviewerName);
                const filename = `${langPart}_${disciplinePart}_${typePart}_${datePart}.csv`;
                downloadFile(csvContent, filename);
                showMessage(`Exported ${valid.length} questions for target ${targetString}`, 5000);
                setShowExportMenu(false);
            };

            // NEW: Export to Sheets Functionality
            const handleExportToSheets = async (sheetUrl) => {
                const sourceList = showHistory ? historicalQuestions : questions;
                const validQuestions = sourceList.filter(q => q.status !== 'rejected');

                if (validQuestions.length === 0) {
                    showMessage("No accepted questions to export.", 3000);
                    return;
                }

                if (!sheetUrl || !sheetUrl.startsWith('http')) {
                    showMessage("Please provide a valid Google Apps Script Web App URL.", 5000);
                    return;
                }


                // Transform into JSON array matching CSV structure (without headers)
                const payloadData = validQuestions.map((row, i) => {
                    const cleanedSourceUrl = row.sourceUrl && !row.sourceUrl.includes("grounding-api") ? row.sourceUrl : "";
                    const o = row.options || {};
                    // Return data fields in the exact order the Google Apps Script expects (matching CSV format)
                    return {
                        id: (i + 1).toString(),
                        uniqueId: row.uniqueId,
                        discipline: row.discipline,
                        type: row.type,
                        difficulty: row.difficulty,
                        question: stripHtmlTags(row.question),
                        optionA: stripHtmlTags(o.A),
                        optionB: stripHtmlTags(o.B),
                        optionC: stripHtmlTags(o.C),
                        optionD: stripHtmlTags(o.D || ""),
                        correctAnswer: row.correct,
                        generationDate: formatDate(new Date()),

                        sourceUrl: cleanedSourceUrl,

                        sourceExcerpt: stripHtmlTags(row.sourceExcerpt),

                        creator: config.creatorName,

                        reviewer: config.reviewerName,

                        language: row.language || "English"

                    };

                });



                setIsProcessing(true);

                setStatus("Sending data to Google Sheets...");
                setShowExportMenu(false);

                try {
                    // WORKAROUND: Since "Anyone" access is restricted, we cannot use fetch().
                    // We must use a Form Submission to a new tab. This forces the browser to send
                    // your authentication cookies, allowing the script to run as "You".

                    const form = document.createElement('form');
                    form.method = 'POST';
                    form.action = sheetUrl;
                    form.target = '_blank'; // Open in new tab to ensure cookies are sent

                    const input = document.createElement('input');
                    input.type = 'hidden';
                    input.name = 'data';
                    input.value = JSON.stringify(payloadData);
                    form.appendChild(input);

                    document.body.appendChild(form);
                    form.submit();
                    document.body.removeChild(form);

                    showMessage(`Export launched in new tab! Check it for "Success" message.`, 7000);

                } catch (e) {
                    console.error("Error pushing to Sheets endpoint:", e);
                    showMessage(`Error connecting to endpoint. Check URL/Console: ${e.message}`, 10000);
                } finally {
                    setIsProcessing(false);
                }
            };


        } finally {
            setIsProcessing(false);
        }
            };

        const handleLoadFromSheets = async () => {
            if (!sheetUrl) { showMessage("Please enter a Google Apps Script URL first.", 3000); return; }

            setIsProcessing(true);
            setStatus("Loading from Google Sheets...");
            setShowExportMenu(false);

            try {
                // We use a simple GET request. 
                // NOTE: This requires the script deployment to be "Anyone" for it to work 
                // without a complex Google Sign-In flow.
                const response = await fetch(sheetUrl);

                if (!response.ok) throw new Error(`HTTP Error: ${response.status}`);

                const json = await response.json();

                if (json.status === 'Success' && Array.isArray(json.data)) {
                    const loadedQuestions = json.data.map(q => ({
                        ...q,
                        id: Date.now() + Math.random(), // Assign new local IDs to avoid conflicts
                        status: 'accepted' // Assume loaded questions are approved
                    }));

                    const uniqueNew = await checkAndStoreQuestions(loadedQuestions);
                    addQuestionsToState(uniqueNew, false);
                    showMessage(`Successfully loaded ${loadedQuestions.length} questions from Sheets!`, 5000);
                } else {
                    throw new Error(json.message || "Invalid data format received");
                }

            } catch (e) {
                console.error("Load Error:", e);
                showMessage(`Load Failed: ${e.message}. (Ensure Script Access is set to 'Anyone')`, 7000);
            } finally {
                setIsProcessing(false);
            }
        };

        const handleBulkTranslateExport = async (targetLanguages) => {

            if (!isApiReady) { showMessage("API key is required for bulk translation. Please enter it in the settings panel.", 5000); return; }



            const sourceList = showHistory ? historicalQuestions : questions;

            const validQuestions = sourceList.filter(q => q.status !== 'rejected');



            if (validQuestions.length === 0 || targetLanguages.length === 0) return;

            setIsProcessing(true); setTranslationProgress(0);
            const exportDate = new Date();
            const datePart = formatDate(exportDate).replace(/-/g, '');
            const totalLanguages = targetLanguages.length;

            const groupedData = validQuestions.reduce((acc, q) => {
                const typeAbbrev = q.type === 'True/False' ? 'T/F' : 'MC';
                const key = `${q.discipline} ${q.difficulty} ${typeAbbrev}`;
                if (!acc[key]) acc[key] = [];
                acc[key].push(q);
                return acc;
            }, {});

            let filesGenerated = 0;
            let completedCount = 0;

            for (const targetLang of targetLanguages) {
                for (const groupKey of Object.keys(groupedData)) {
                    const groupQuestions = groupedData[groupKey];
                    setStatus(`Translating ${groupKey} to ${targetLang} (Batching)...`);

                    const batches = chunkArray(groupQuestions, 6);
                    let finalTranslatedGroup = [];

                    try {
                        for (const batch of batches) {
                            let rawTable = "| ID | Discipline | Type | Difficulty | Question | Answer | OptionA | OptionB | OptionC | OptionD | CorrectLetter | SourceURL | SourceExcerpt |\n|---|---|---|---|---|---|---|---|---|---|---|---|---|\n";
                            batch.forEach((q, i) => {
                                const opts = q.options || {};
                                rawTable += `| ${i + 1} | ${stripHtmlTags(q.discipline)} | ${stripHtmlTags(q.type)} | ${stripHtmlTags(q.difficulty)} | ${stripHtmlTags(q.question)} | | ${stripHtmlTags(opts.A || '')} | ${stripHtmlTags(opts.B || '')} | ${stripHtmlTags(opts.C || '')} | ${stripHtmlTags(opts.D || '')} | ${q.correct} | ${stripHtmlTags(q.sourceUrl)} | ${stripHtmlTags(q.sourceExcerpt)} |\n`;
                            });

                            const sourceLang = config.language;
                            const systemPrompt = `
                                    You are a professional technical translator for Unreal Engine 5 documentation. Translate the provided Markdown table from ${sourceLang} to ${targetLang}.
                                    CRITICAL INSTRUCTIONS:
                                    1. Preserve the exact Markdown table structure, including the pipe characters (|) and the header row.
                                    2. Translate ONLY the following columns: Question, OptionA, OptionB, OptionC, OptionD, and SourceExcerpt.
                                    3. DO NOT translate: ID, Discipline, Type, Difficulty, Answer (column 6), CorrectLetter, and SourceURL.
                                    4. **Translate ALL rows. Do not summarize or skip any rows.**
                                    5. Ensure you use standard half-width pipe characters (|) for column separators, not full-width (ï½œ).
                                    `;

                            // Pass effectiveKey
                            const translatedText = await generateContent(effectiveApiKey, systemPrompt, `Translate the following ${sourceLang} question bank table to ${targetLang}:\n${rawTable}`, setStatus);
                            const translatedQuestions = parseQuestions(translatedText);

                            const remappedBatch = translatedQuestions.map((tq, i) => ({
                                ...tq,
                                id: Date.now() + Math.random(),
                                uniqueId: batch[i]?.uniqueId || tq.uniqueId,
                                discipline: batch[i].discipline,
                                type: batch[i].type,
                                difficulty: batch[i].difficulty,
                                language: targetLang,
                                status: 'accepted'
                            }));

                            await checkAndStoreQuestions(remappedBatch);

                            finalTranslatedGroup.push(...remappedBatch);
                        }

                        if (finalTranslatedGroup.length > 0) {
                            const csvContent = getCSVContent(finalTranslatedGroup, config.creatorName, config.reviewerName);
                            const fileNameParts = groupKey.replace(/ & /g, '_').replace(/ /g, '_');
                            const langPart = targetLang.replace(/ /g, '_');
                            const filename = `${fileNameParts}_${datePart}_${langPart}.csv`;
                            downloadFile(csvContent, filename);
                            filesGenerated++;
                        }

                    } catch (e) {
                        console.error(`Translation of group ${groupKey} to ${targetLang} failed:`, e);
                        showMessage(`Error translating group ${groupKey} to ${targetLang}. See console.`, 5000);
                    }
                }
                completedCount++;
                setTranslationProgress(Math.floor((completedCount / totalLanguages) * 100));
            }
            setStatus(`Successfully exported ${filesGenerated} translated file(s).`);
            setTranslationProgress(100);
            setIsProcessing(false);
        };

        const handleBulkTranslateMissing = async () => {
            if (isProcessing) return;
            if (!isApiReady) { showMessage("API key is required for bulk translation. Please enter it in the settings panel.", 5000); return; }

            setIsProcessing(true);
            setShowHistory(false);

            // 1. Identify unique questions that need CN, JP, or KR translations
            const targetLangs = ['Chinese (Simplified)', 'Japanese', 'Korean'];
            const translationQueue = [];

            // Find English/Base versions
            const baseQuestions = Array.from(allQuestionsMap.values()).map(variants =>
                variants.find(v => (v.language || 'English') === 'English') || variants[0]
            );

            baseQuestions.forEach(q => {
                const existingLangs = translationMap.get(q.uniqueId) || new Set();

                targetLangs.forEach(targetLang => {
                    if (q.status === 'accepted' && !existingLangs.has(targetLang)) {
                        // Only queue accepted, missing translations
                        translationQueue.push({ question: q, targetLang });
                    }
                });
            });

            if (translationQueue.length === 0) {
                showMessage("All CN, JP, and KR translations already exist for all accepted questions.", 5000);
                setIsProcessing(false);
                return;
            }

            showMessage(`Found ${translationQueue.length} missing translations. Starting bulk generation...`);
            let generatedCount = 0;
            let totalProgress = 0;
            const totalQueueSize = translationQueue.length;

            for (const { question: q, targetLang } of translationQueue) {
                const rawTable = `| ID | Discipline | Type | Difficulty | Question | Answer | OptionA | OptionB | OptionC | OptionD | CorrectLetter | SourceURL | SourceExcerpt |\n|---|---|---|---|---|---|---|---|---|---|---|---|---|\n| 1 | ${q.discipline} | ${q.type} | ${q.difficulty} | ${q.question} | | ${q.options.A} | ${q.options.B} | ${q.options.C || ''} | ${q.options.D || ''} | ${q.correct} | ${q.sourceUrl} | ${q.sourceExcerpt} |`;
                const prompt = `Translate this single row from ${q.language || 'English'} to ${targetLang}. Keep format EXACT. \n${rawTable}`;
                const systemPrompt = `You are a professional technical translator for Unreal Engine 5 documentation. Translate the provided Markdown table from ${q.language || 'English'} to ${targetLang}. CRITICAL INSTRUCTIONS: 1. Preserve the exact Markdown table structure. 2. Translate ONLY: Question, OptionA, OptionB, OptionC, OptionD, and SourceExcerpt. 3. DO NOT translate: ID, Discipline, Type, Difficulty, Answer, CorrectLetter, and SourceURL.`;

                try {
                    setStatus(`Translating: ${q.uniqueId.substring(0, 4)} -> ${targetLang}...`);
                    // Pass effectiveKey
                    const text = await generateContent(effectiveApiKey, systemPrompt, prompt, setStatus);
                    const translatedQs = parseQuestions(text);

                    if (translatedQs.length > 0) {
                        const tq = translatedQs[0];
                        const newQuestion = {
                            ...tq,
                            id: Date.now() + Math.random(),
                            uniqueId: q.uniqueId,
                            discipline: q.discipline,
                            type: q.type,
                            difficulty: q.difficulty,
                            language: targetLang,
                            status: 'accepted',
                            dateAdded: new Date().toISOString()
                        };

                        await checkAndStoreQuestions([newQuestion]);
                        addQuestionsToState([newQuestion], showHistory);
                        generatedCount++;
                    }
                } catch (e) {
                    console.error(`Failed to generate translation for ${q.uniqueId} to ${targetLang}:`, e);
                }

                totalProgress = Math.floor((generatedCount / totalQueueSize) * 100);
                setTranslationProgress(totalProgress);
            }

            showMessage(`Bulk translation complete! Generated ${generatedCount} new translations.`, 7000);
            setIsProcessing(false);
        };


        const handleUpdateStatus = (id, newStatus) => {
            const targetSet = showHistory ? setHistoricalQuestions : setQuestions;
            targetSet(prev => prev.map(q => q.id === id ? { ...q, status: newStatus, critique: newStatus === 'accepted' ? null : q.critique } : q));
        };

        const handleSelectCategory = (categoryKey) => {
            setConfig(prev => ({ ...prev, difficulty: categoryKey }));
        };

        // --- ALL FILTERING LOGIC COMBINED (useMemo provides stable array) ---
        const uniqueFilteredQuestions = useMemo(() => {
            const sourceList = showHistory ? historicalQuestions : questions;
            const currentLanguage = config.language;
            const targetDifficulty = config.difficulty.split(' ')[0];
            const targetTypeAbbrev = config.difficulty.split(' ')[1];
            const targetType = targetTypeAbbrev === 'MC' ? 'Multiple Choice' : 'True/False';

            // 1. Apply Global Filters (Status, Search Term, Creator, and DISCIPLINE)
            const filteredByGlobal = sourceList.filter(q => {

                // --- FIX: Ensure status filter works correctly for session questions ---
                let statusMatch = true;
                if (!showHistory && filterMode !== 'all') {
                    statusMatch = q.status === filterMode;
                }

                const textMatch = (q.question && q.question.toLowerCase().includes(searchTerm.toLowerCase())) ||
                    (q.uniqueId && q.uniqueId.toLowerCase().includes(searchTerm.toLowerCase())) ||
                    (q.discipline && q.discipline.toLowerCase().includes(searchTerm.toLowerCase())) ||
                    (q.difficulty && q.difficulty.toLowerCase().includes(searchTerm.toLowerCase()));

                let creatorMatch = true;
                if (filterByCreator && config.creatorName) {
                    const qCreator = (q.creatorName || '').toLowerCase().trim();
                    const configCreator = config.creatorName.toLowerCase().trim();
                    creatorMatch = (qCreator === configCreator);
                }

                // --- Discipline Filter (REQUIRED by user) ---
                const disciplineMatch = q.discipline === config.discipline;

                return statusMatch && textMatch && creatorMatch && disciplineMatch;
            });

            // 2. Group by uniqueId
            const grouped = new Map();
            filteredByGlobal.forEach(q => {
                const id = q.uniqueId;
                if (!grouped.has(id)) grouped.set(id, []);
                grouped.get(id).push(q);
            });

            const finalDisplayList = [];

            // 3. For each unique question ID, select the best language version AND apply category filter
            grouped.forEach((variants) => {

                // Filter variants by Difficulty/Type based on sidebar selection
                let filteredVariants = variants;
                if (config.difficulty !== 'Balanced All') {
                    filteredVariants = variants.filter(v => {
                        const qDiff = (v.difficulty || '').toLowerCase();
                        const vType = (v.type || '').toLowerCase();
                        return (qDiff === targetDifficulty.toLowerCase() && vType === targetType.toLowerCase());
                    });
                }

                if (filteredVariants.length === 0) return; // Skip if no variant matches difficulty/type filter

                let selected = null;

                // A. Try to find an exact language match
                selected = filteredVariants.find(v => (v.language || 'English') === currentLanguage);

                // B. Fallback 1: English
                if (!selected) {
                    selected = filteredVariants.find(v => (v.language || 'English') === 'English');
                }

                // C. Fallback 2: Any available language (take the first one)
                if (!selected) {
                    selected = filteredVariants[0];
                }

                if (selected) {
                    finalDisplayList.push(selected);
                }
            });

            return finalDisplayList;
        }, [historicalQuestions, questions, config.language, config.discipline, config.difficulty, filterMode, searchTerm, filterByCreator, config.creatorName, showHistory]);

        // Expose the raw array for UI checks outside useMemo
        const filteredQuestions = uniqueFilteredQuestions;

        // Calculate overall stats for visibility
        const totalApproved = useMemo(() => {
            return CATEGORY_KEYS.reduce((sum, key) => sum + approvedCounts[key], 0);
        }, [approvedCounts]);

        const overallPercentage = useMemo(() => {
            return Math.min(100, (totalApproved / TARGET_TOTAL) * 100);
        }, [totalApproved]);

        const apiKeyStatus = isInternalEnvironment ? 'Auto-Auth' : (config.apiKey.length > 5 ? 'Loaded' : 'Missing');

        const handleModeSelect = (mode) => {
            setAppMode(mode);
            if (mode === 'review') {
                setShowHistory(true);
                setFilterMode('all');
            } else {
                // Creation mode defaults
                setShowHistory(false);
                setFilterMode('pending');
            }
        };

        const handleGoHome = () => {
            setAppMode('landing');
        };

        if (appMode === 'landing') {
            return <LandingPage onSelectMode={handleModeSelect} apiKeyStatus={apiKeyStatus} isCloudReady={isCloudReady} />;
        }

        return (
            <div className="flex flex-col h-screen bg-slate-950 font-sans text-slate-200">
                {config.creatorName === '' && <NameEntryModal onSave={handleNameSave} />}
                {showClearModal && <ClearConfirmationModal onConfirm={handleDeleteAllQuestions} onCancel={() => setShowClearModal(false)} />}
                {appMode === 'create' && (
                    <aside className="w-80 flex-shrink-0 z-10 shadow-xl border-r border-slate-700 bg-slate-950 p-6 overflow-y-auto flex flex-col gap-6">

                        {/* NEW OVERALL PROGRESS BOX */}
                        <div className="bg-slate-900 rounded-lg p-4 border border-slate-800 shadow-inner space-y-3">
                            <div className="text-center">
                                <h3 className="text-xl font-extrabold text-white">{allQuestionsMap.size}</h3>
                                <p className="text-xs font-semibold uppercase text-slate-400">UNIQUE QUESTIONS IN DB</p>
                            </div>
                            <div className="border-t border-slate-800 pt-3 space-y-1">
                                <div className="flex justify-between items-end">
                                    <h3 className="text-xs font-bold text-slate-300">APPROVED QUOTA ({totalApproved}/{TARGET_TOTAL})</h3>
                                    <span className="text-xs font-bold text-orange-400">{overallPercentage.toFixed(1)}%</span>
                                </div>
                                <div className="w-full h-1.5 rounded-full overflow-hidden bg-slate-700">
                                    <div className="h-full bg-orange-600 transition-all duration-500" style={{ width: `${overallPercentage}%` }}></div>
                                </div>
                            </div>
                        </div>

                        <GranularProgress approvedCounts={approvedCounts} target={TARGET_PER_CATEGORY} isTargetMet={isTargetMet} selectedDifficulty={config.difficulty} handleSelectCategory={handleSelectCategory} />

                        {/* API Key Configuration */}
                        <div className="bg-slate-900 rounded-lg p-4 border border-slate-800 shadow-inner space-y-2">
                            <div className="flex items-center">
                                <label className="text-xs font-bold uppercase text-slate-400 tracking-wider flex items-center gap-2">
                                    <Icon name="key" size={12} /> Gemini API Key
                                </label>
                                <InfoTooltip text="Enter your personal Gemini API key here. Required if running outside the Canvas environment." />
                            </div>
                            <input
                                type="password"
                                name="apiKey"
                                value={config.apiKey}
                                onChange={handleChange}
                                className="w-full px-3 py-2 bg-slate-950 border border-slate-700 rounded text-sm text-slate-200 placeholder-slate-600 outline-none focus:border-orange-500"
                                placeholder={isInternalEnvironment ? "Auto-Auth Enabled" : "Enter your key..."}
                                disabled={isInternalEnvironment}
                            />
                            <div className={`text-xs font-mono text-right ${apiKeyStatus.includes('Loaded') || apiKeyStatus.includes('Auto') ? 'text-green-500' : 'text-red-500'}`}>
                                {apiKeyStatus}
                            </div>
                        </div>

                        <div className="bg-slate-900 rounded-lg p-4 border border-slate-800 shadow-inner">
                            <div className="flex items-center mb-2">
                                <label className="text-xs font-bold uppercase text-slate-400 tracking-wider flex items-center gap-2"><Icon name="hash" size={12} /> Batch Size (Max {maxBatchSize})</label>
                                <InfoTooltip text="Number of questions to generate in one batch. Dynamically capped by remaining quota." />
                            </div>
                            <input type="number" min="1" max={maxBatchSize} name="batchSize" value={config.batchSize} onChange={handleChange} className="w-full px-3 py-2 bg-slate-900 border border-slate-700 rounded text-sm text-slate-200 placeholder-slate-600 outline-none focus:border-orange-500" placeholder="e.g. 6, 12, 18" />
                        </div>
                        <div className="pb-4 space-y-3">
                            <button onClick={handleGenerate} disabled={isGenerating || isTargetMet || maxBatchSize === 0 || !isApiReady} className={`w-full py-4 px-4 rounded-lg font-bold text-white flex items-center justify-center gap-2 transition-all shadow-lg ${isGenerating || isTargetMet || maxBatchSize === 0 || !isApiReady ? 'bg-slate-700 cursor-not-allowed' : 'bg-orange-600 hover:bg-orange-700 active:scale-[0.98]'}`}>
                                {isGenerating ? <><Icon name="loader" size={16} className="animate-spin" /> GENERATING...</> : <><Icon name="book-open" size={16} /> GENERATE QUESTIONS</>}
                            </button>

                            <button onClick={handleBulkTranslateMissing} disabled={isProcessing || isGenerating || Array.from(allQuestionsMap.keys()).length === 0 || !isApiReady} className={`w-full py-2 px-4 rounded-lg font-bold text-xs flex items-center justify-center gap-2 transition-all border ${isProcessing || isGenerating || Array.from(allQuestionsMap.keys()).length === 0 || !isApiReady ? 'bg-slate-800 text-slate-600 cursor-not-allowed' : 'bg-indigo-950/50 text-indigo-400 hover:bg-indigo-900/50 border-indigo-700'}`}>
                                <Icon name="languages" size={14} /> BULK TRANSLATE (CN/JP/KR)
                            </button>
                        </div>
                        <div className="space-y-4">

                            <div className="space-y-1">
                                <div className="flex items-center"><label className="text-xs font-bold uppercase text-slate-400">Discipline</label><InfoTooltip text="Topic focus" /></div>
                                <select name="discipline" value={config.discipline} onChange={handleChange} className="w-full px-3 py-2 bg-slate-900 border border-slate-700 rounded text-sm outline-none focus:border-orange-500">
                                    <option value="Technical Art">Technical Art</option><option value="Animation & Rigging">Animation & Rigging</option><option value="Game Logic & Systems">Game Logic & Systems</option><option value="Look Development (Materials)">Look Development (Materials)</option><option value="Networking">Networking</option><option value="C++ Programming">C++ Programming</option><option value="VFX (Niagara)">VFX (Niagara)</option><option value="World Building & Level Design">World Building & Level Design</option><option value="Blueprints">Blueprints</option><option value="Lighting & Rendering">Lighting & Rendering</option>
                                </select>
                            </div>
                            <div className="space-y-1">
                                <div className="flex items-center"><label className="text-xs font-bold uppercase text-slate-400">Language</label></div>
                                <select name="language" value={config.language} onChange={handleChange} className="w-full px-3 py-2 bg-slate-900 border border-slate-700 rounded text-sm outline-none focus:border-orange-500">
                                    <option>English</option><option>Chinese (Simplified)</option><option>Japanese</option><option>Korean</option><option>Spanish</option><option>French</option>
                                </select>
                            </div>
                        </div>
                        <div className="mt-auto pt-6 border-t border-slate-800 space-y-3">
                            <div className="flex justify-between items-end"><label className="text-xs font-bold uppercase text-slate-400">Source Files</label>{files.length > 0 && <button onClick={handleDetectTopics} disabled={isDetecting || !isApiReady} className="text-[10px] flex items-center gap-1 text-indigo-400 bg-indigo-900/50 px-2 py-1 rounded border border-indigo-700/50">{isDetecting ? "..." : "Detect"}</button>}</div>
                            <div onClick={() => fileInputRef.current?.click()} className="border-2 border-dashed border-slate-700 rounded p-4 hover:bg-slate-900 cursor-pointer text-center bg-slate-900/50"><Icon name="upload" className="mx-auto text-slate-600 mb-2" /><p className="text-xs text-slate-500">Upload .csv</p><input type="file" ref={fileInputRef} onChange={handleFileChange} multiple className="hidden" /></div>
                            {files.map((f, i) => <div key={i} className="flex justify-between bg-slate-900 p-2 rounded border border-slate-800 text-xs text-slate-400"><span className="truncate">{f.name}</span><button onClick={() => removeFile(i)} className="text-red-500">x</button></div>)}
                        </div>
                    </aside>
                )}
                <main className="flex-1 flex flex-col min-w-0 bg-slate-950">
                    <div className="flex justify-between items-center p-4 border-b border-slate-800 bg-slate-900 shadow-md z-10">
                        <div className="flex gap-4 items-center">
                            {isAuthReady ? (<>{status && <span className="text-xs text-orange-500 font-medium flex items-center gap-1 animate-pulse"><Icon name="loader" size={12} className="animate-spin" /> {status}</span>}{!status && <span className="text-xs font-bold text-slate-500 uppercase flex items-center gap-2"><Icon name="database" size={14} /> DB Ready</span>}</>) : (<span className="text-xs text-yellow-500 font-medium flex items-center gap-1 animate-pulse"><Icon name="plug" size={12} className="animate-pulse" /> Connecting to DB...</span>)}

                            {/* Only show filters/stats if NOT in Review Mode, or if Review Mode and data loaded */}
                            {appMode === 'review' && (
                                <div className="flex gap-2 items-center ml-4">
                                    <div className="px-3 py-1 bg-indigo-900/30 border border-indigo-700/50 rounded text-xs text-indigo-300 font-bold flex items-center gap-2">
                                        <Icon name="list-checks" size={14} />
                                        REVIEW MODE: {historicalQuestions.length} Items
                                    </div>
                                </div>
                            )}
                        </div>
                        <div className="flex gap-2 items-center bg-slate-950 p-1 rounded-lg border border-slate-800 shadow-inner">
                            {/* Only show history toggle in Creation Mode */}
                            {appMode === 'create' && (
                                <button onClick={handleToggleHistory} className={`px-3 py-1 text-xs font-medium rounded transition-all flex items-center gap-1 ${showHistory ? 'bg-purple-600 text-white shadow-md shadow-purple-900/50' : 'bg-slate-800 text-slate-400 hover:bg-slate-700/50'}`} title={showHistory ? 'Back to Current Session' : 'View Full Question History'}><Icon name={showHistory ? 'list' : 'archive'} size={12} />{showHistory ? 'Current Session' : 'Full History'} <span className="text-[10px] bg-slate-950/50 px-1.5 rounded-full">{showHistory ? historicalQuestions.length : questions.length}</span></button>
                            )}

                            {/* In Review Mode or History view, filter by status makes sense */}
                            {((!showHistory && questions.length > 0) || (showHistory && historicalQuestions.length > 0) || appMode === 'review') && (
                                <>
                                    <div className="w-px h-4 bg-slate-700 mx-1"></div>
                                    {/* In Review Mode, usually everything is 'accepted' unless rejected in this session, but let's keep filters */}
                                    {appMode !== 'review' && <FilterButton mode="pending" current={filterMode} setFilter={setFilterMode} label="Pending" count={pendingCount} />}
                                    <FilterButton mode="all" current={filterMode} setFilter={setFilterMode} label="All" count={appMode === 'review' ? historicalQuestions.length : questions.length} />
                                    {appMode !== 'review' && <FilterButton mode="accepted" current={filterMode} setFilter={setFilterMode} label="Accepted" count={approvedCount} />}
                                    <FilterButton mode="rejected" current={filterMode} setFilter={setFilterMode} label="Rejected" count={rejectedCount} />
                                </>
                            )}

                            <div className="w-px h-4 bg-slate-700 mx-1"></div>
                            <button
                                onClick={() => setFilterByCreator(!filterByCreator)}
                            <input type="text" placeholder="Search by ID, Question Text, Option, or Discipline..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="w-full bg-slate-900 text-slate-300 placeholder-slate-600 border-none outline-none focus:ring-0 text-sm" />
                            {searchTerm && (<button onClick={() => setSearchTerm('')} className="text-slate-500 hover:text-red-400 p-1 rounded"><Icon name="x" size={16} /></button>)}

                            {/* In Review Mode, add a Language Filter Dropdown here since sidebar is gone */}
                            {appMode === 'review' && (
                                <div className="flex items-center gap-2 ml-4 border-l border-slate-700 pl-4">
                                    <label className="text-xs font-bold uppercase text-slate-500 whitespace-nowrap">Language:</label>
                                    <select name="language" value={config.language} onChange={handleChange} className="px-2 py-1 bg-slate-800 border border-slate-700 rounded text-xs outline-none focus:border-indigo-500">
                                        <option>English</option><option>Chinese (Simplified)</option><option>Japanese</option><option>Korean</option><option>Spanish</option><option>French</option>
                                    </select>
                                </div>
                            )}
                        </div>

                        <div className="flex-1 overflow-auto p-6 bg-black/20 space-y-4">
                            {!showHistory && uniqueFilteredQuestions.length === 0 && questions.length === 0 && !status && appMode === 'create' && (<div className="flex flex-col items-center justify-center h-full text-slate-600"><Icon name="terminal" size={48} className="mb-4 text-slate-800" /><p className="font-medium text-slate-500">Ready. Click 'GENERATE QUESTIONS' to begin or upload a source file.</p></div>)}

                            {uniqueFilteredQuestions.map(q => (
                                <QuestionItem
                                    key={q.uniqueId}
                                    q={q}
                                    onUpdateStatus={handleUpdateStatus}
                                    onExplain={handleExplain}
                                    onVariate={handleVariate}
                                    onCritique={handleCritique}
                                    onTranslateSingle={handleTranslateSingle}
                                    onSwitchLanguage={handleLanguageSwitch}
                                    availableLanguages={translationMap.get(q.uniqueId)}
                                    isProcessing={isProcessing}
                                />
                            ))}

                            {uniqueFilteredQuestions.length === 0 && filteredQuestions.length > 0 && (
                                <div className="flex flex-col items-center justify-center h-full text-slate-600 pt-10">
                                    <Icon name="filter" size={32} className="mb-3 text-slate-800" />
                                    <p className="font-medium text-slate-500">No questions match current filters.</p>
                                    {filterByCreator && (
                                        <p className="text-xs text-slate-600 mt-2">
                                            Filtering by Creator: <span className="text-blue-500 font-bold">{config.creatorName}</span>.
                                            <button onClick={() => setFilterByCreator(false)} className="ml-2 underline hover:text-blue-400">Show All Creators?</button>
                                        </p>
                                    )}
                                </div>
                            )}
                        </div>
                </main>
            </div>
            </div >
        );
                    };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>